{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Homie for ESP8266 docs. This will help you to understand the framework and to use it in an effective manner. This documentation is valid for Homie v1.5.0 1. What is it? \u00b6 2. Getting started \u00b6 3. Advanced usage \u00b6 4. OTA \u00b6 5. JSON configuration file \u00b6 6. Configuration API \u00b6 7. API reference \u00b6 8. Limitations and known issues \u00b6 9. Troubleshooting \u00b6","title":"Welcome"},{"location":"#1-what-is-it","text":"","title":"1. What is it?"},{"location":"#2-getting-started","text":"","title":"2. Getting started"},{"location":"#3-advanced-usage","text":"","title":"3. Advanced usage"},{"location":"#4-ota","text":"","title":"4. OTA"},{"location":"#5-json-configuration-file","text":"","title":"5. JSON configuration file"},{"location":"#6-configuration-api","text":"","title":"6. Configuration API"},{"location":"#7-api-reference","text":"","title":"7. API reference"},{"location":"#8-limitations-and-known-issues","text":"","title":"8. Limitations and known issues"},{"location":"#9-troubleshooting","text":"","title":"9. Troubleshooting"},{"location":"1.-What-is-it/","text":"What is it? \u00b6 Homie for ESP8266 is an ESP8266 for Arduino implementation of Homie , a thin and simple MQTT convention for the IoT. More than that, it's also a full-featured framework to get started with your IoT project very quickly. Simply put, you don't have to manage yourself the connection/reconnection to the Wi-Fi/MQTT. You don't even have to hard-code credentials in your sketch: this can be done using a simple JSON API. Everything is handled internally, by Homie for ESP8266. You guessed it, the purpose of Homie for ESP8266 is to simplify the development of connected objects.","title":"What is it?"},{"location":"1.-What-is-it/#what-is-it","text":"Homie for ESP8266 is an ESP8266 for Arduino implementation of Homie , a thin and simple MQTT convention for the IoT. More than that, it's also a full-featured framework to get started with your IoT project very quickly. Simply put, you don't have to manage yourself the connection/reconnection to the Wi-Fi/MQTT. You don't even have to hard-code credentials in your sketch: this can be done using a simple JSON API. Everything is handled internally, by Homie for ESP8266. You guessed it, the purpose of Homie for ESP8266 is to simplify the development of connected objects.","title":"What is it?"},{"location":"2.-Getting-started/","text":"Getting started \u00b6 This Getting Started guide assumes you have an ESP8266 board with an user-configurable LED, and an user programmable button, like a NodeMCU DevKit 1.0, for example. These restrictions can be lifted. (see Advanced usage ) To use Homie for ESP8266, you will need: An ESP8266 The Arduino IDE for ESP8266 (version 2.2.0 minimum) Basic knowledge of the Arduino environment (upload a sketch, import libraries, ...) To understand the Homie convention Installing Homie for ESP8266 \u00b6 There are two ways to install Homie for ESP8266. 1a. For the Arduino IDE \u00b6 Download the latest release Load the .zip with Sketch \u2192 Include Library \u2192 Add .ZIP Library Homie for ESP8266 has 3 dependencies: ArduinoJson , Bounce2 and PubSubClient . You can install them through the Arduino IDE, with Sketch \u2192 Include Library \u2192 Manage Libraries . Be sure the installed version is >= 5.0.8 for ArduinoJson , >= 2.0 for Bounce2 , >= 2.5 for PubSubClient . 1b. With PlatformIO \u00b6 In a terminal, run platformio lib install 555 . Dependencies are installed automatically. Bare minimum sketch \u00b6 #include <Homie.h> void setup () { Homie . setup (); } void loop () { Homie . loop (); } This is the bare minimum needed for Homie for ESP8266 to work correctly. If you upload this sketch, you will notice the LED of the ESP8266 will light on . This is because you are in configuration mode. Homie for ESP8266 has 3 modes of operation: The configuration mode is the initial one. It spawns an AP and an HTTP webserver exposing a JSON API. To interact with it, you have to connect to the AP. Then, an HTTP client can get the list of available Wi-Fi networks, and send the credentials (like the Wi-Fi SSID, the Wi-Fi password, ...). Once the device receives the credentials, it boots into normal mode. The normal mode is the mode the device will be most of the time. It connects to the Wi-Fi, to the MQTT, it sends initial informations to the Homie server (like the local IP, the version of the firmware currently running, ...) and it subscribes from the MQTT to properties change. The device can return to configuration mode in different ways (press of a button or custom function, see 3. Advanced usage ). The OTA mode is triggered from the normal mode when the MQTT server sends a version different from the current firmware version. It will reach the OTA HTTP server and flash the latest firmware available. When it ends (either a success or a failure), it returns to normal mode. Very important: As a rule of thumb, never block the device with blocking code for more than 50ms or so. Otherwise, you may very probably experience unexpected behaviors. Connecting to the AP and configuring the device \u00b6 Homie for ESP8266 has spawned a secure AP named Homie-xxxxxxxx . For example, if the AP is named Homie-c631f278 , the AP password is c631f278 . Connect to it. Note : This c631f278 ID is unique to each device, and you cannot change it. If you reflash a new sketch, this ID won't change. Once connected, the webserver is available at http://homie.config . To bypass the built-in DNS server, you can reach directly 192.168.1.1 . You can then configure the device using the Configuration API . When the device receives its configuration, it will reboot to normal mode. Understanding what happens in normal mode \u00b6 Visual codes \u00b6 When the device boots in normal mode, it will start blinking: Slowly when connecting to the Wi-Fi Faster when connecting to the MQTT broker This way, you can have a quick feedback on what's going on. If both connections are established, the LED will stay off. Note the device will also blink during the automatic reconnection, if the connection to the Wi-Fi or the MQTT broker is lost. Under the hood \u00b6 Although the sketch looks like it does not do anything, it actually does quite a lot: It automatically connects to the Wi-Fi and MQTT broker. No more network boilerplate code It exposes the Homie device on MQTT (as devices / device ID , e.g. devices/c631f278 ). It subscribes to the special device property $ota , automatically rebooting in OTA mode if OTA is available It checks for a button press on the ESP8266, to return to configuration mode Creating an useful sketch \u00b6 Now that we understand how Homie for ESP8266 works, let's create an useful sketch. We want to create a smart light. #include <Homie.h> const int PIN_RELAY = 5 ; HomieNode lightNode ( \"light\" , \"switch\" ); bool lightOnHandler ( String value ) { if ( value == \"true\" ) { digitalWrite ( PIN_RELAY , HIGH ); Homie . setNodeProperty ( lightNode , \"on\" , \"true\" ); // Update the state of the light Serial . println ( \"Light is on\" ); } else if ( value == \"false\" ) { digitalWrite ( PIN_RELAY , LOW ); Homie . setNodeProperty ( lightNode , \"on\" , \"false\" ); Serial . println ( \"Light is off\" ); } else { return false ; } return true ; } void setup () { pinMode ( PIN_RELAY , OUTPUT ); digitalWrite ( PIN_RELAY , LOW ); Homie . setFirmware ( \"awesome-relay\" , \"1.0.0\" ); lightNode . subscribe ( \"on\" , lightOnHandler ); Homie . registerNode ( lightNode ); Homie . setup (); } void loop () { Homie . loop (); } Alright, step by step: We create a node with an ID of light and a type of switch with HomieNode lightNode(\"light\", \"switch\") We set the name and the version of the firmware with Homie.setFirmware(\"awesome-light\" ,\"1.0.0\"); We want our light node to subscribe to the on property. We do that with lightNode.subscribe(\"on\", lightOnHandler); . The lightOnHandler function will be called when the value of this property is changed We tell Homie for ESP8266 to expose our light node by registering it. We do this with Homie.registerNode(lightNode); In the lightOnHandler function, we want to update the state of the light node. We do this with Homie.setNodeProperty(lightNode, \"on\", \"true\"); In about thirty SLOC, we have achieved to create a smart light, without any hard-coded credentials, with automatic reconnection in case of network failure, and with OTA support. Not bad, right? Creating a sensor node \u00b6 In the previous example sketch, we were reacting on property changes. But what if we want, for example, to send a temperature every 5 minute? We could do this in the Arduino loop() function. But then, we would have to check if we are in normal mode, and we would have to ensure the network connection is up before sending any property. Boring. Fortunately, Homie for ESP8266 provides an easy way to do that. #include <Homie.h> const int TEMPERATURE_INTERVAL = 300 ; unsigned long lastTemperatureSent = 0 ; HomieNode temperatureNode ( \"temperature\" , \"temperature\" ); void setupHandler () { // Do what you want to prepare your sensor } void loopHandler () { if ( millis () - lastTemperatureSent >= TEMPERATURE_INTERVAL * 1000UL || lastTemperatureSent == 0 ) { float temperature = 22 ; // Fake temperature here, for the example Serial . print ( \"Temperature: \" ); Serial . print ( temperature ); Serial . println ( \" \u00b0C\" ); if ( Homie . setNodeProperty ( temperatureNode , \"temperature\" , String ( temperature ), true )) { lastTemperatureSent = millis (); } else { Serial . println ( \"Sending failed\" ); } } } void setup () { Homie . setFirmware ( \"awesome-temperature\" , \"1.0.0\" ); Homie . registerNode ( temperatureNode ); Homie . setSetupFunction ( setupHandler ); Homie . setLoopFunction ( loopHandler ); Homie . setup (); } void loop () { Homie . loop (); } The only new things here are the Homie.setSetupFunction(setupHandler); and Homie.setLoopFunction(loopHandler); calls. The setup function will be called once, when the device is in normal mode and the network connection is up. The loop function will be called everytime, when the device is in normal mode and the network connection is up. This provides a nice level of abstraction. Now that you understand the basic usage of Homie for ESP8266, you can head on to the Advanced usage page to learn about more powerful features like input handlers and the event system.","title":"Getting started"},{"location":"2.-Getting-started/#getting-started","text":"This Getting Started guide assumes you have an ESP8266 board with an user-configurable LED, and an user programmable button, like a NodeMCU DevKit 1.0, for example. These restrictions can be lifted. (see Advanced usage ) To use Homie for ESP8266, you will need: An ESP8266 The Arduino IDE for ESP8266 (version 2.2.0 minimum) Basic knowledge of the Arduino environment (upload a sketch, import libraries, ...) To understand the Homie convention","title":"Getting started"},{"location":"2.-Getting-started/#installing-homie-for-esp8266","text":"There are two ways to install Homie for ESP8266.","title":"Installing Homie for ESP8266"},{"location":"2.-Getting-started/#1a-for-the-arduino-ide","text":"Download the latest release Load the .zip with Sketch \u2192 Include Library \u2192 Add .ZIP Library Homie for ESP8266 has 3 dependencies: ArduinoJson , Bounce2 and PubSubClient . You can install them through the Arduino IDE, with Sketch \u2192 Include Library \u2192 Manage Libraries . Be sure the installed version is >= 5.0.8 for ArduinoJson , >= 2.0 for Bounce2 , >= 2.5 for PubSubClient .","title":"1a. For the Arduino IDE"},{"location":"2.-Getting-started/#1b-with-platformio","text":"In a terminal, run platformio lib install 555 . Dependencies are installed automatically.","title":"1b. With PlatformIO"},{"location":"2.-Getting-started/#bare-minimum-sketch","text":"#include <Homie.h> void setup () { Homie . setup (); } void loop () { Homie . loop (); } This is the bare minimum needed for Homie for ESP8266 to work correctly. If you upload this sketch, you will notice the LED of the ESP8266 will light on . This is because you are in configuration mode. Homie for ESP8266 has 3 modes of operation: The configuration mode is the initial one. It spawns an AP and an HTTP webserver exposing a JSON API. To interact with it, you have to connect to the AP. Then, an HTTP client can get the list of available Wi-Fi networks, and send the credentials (like the Wi-Fi SSID, the Wi-Fi password, ...). Once the device receives the credentials, it boots into normal mode. The normal mode is the mode the device will be most of the time. It connects to the Wi-Fi, to the MQTT, it sends initial informations to the Homie server (like the local IP, the version of the firmware currently running, ...) and it subscribes from the MQTT to properties change. The device can return to configuration mode in different ways (press of a button or custom function, see 3. Advanced usage ). The OTA mode is triggered from the normal mode when the MQTT server sends a version different from the current firmware version. It will reach the OTA HTTP server and flash the latest firmware available. When it ends (either a success or a failure), it returns to normal mode. Very important: As a rule of thumb, never block the device with blocking code for more than 50ms or so. Otherwise, you may very probably experience unexpected behaviors.","title":"Bare minimum sketch"},{"location":"2.-Getting-started/#connecting-to-the-ap-and-configuring-the-device","text":"Homie for ESP8266 has spawned a secure AP named Homie-xxxxxxxx . For example, if the AP is named Homie-c631f278 , the AP password is c631f278 . Connect to it. Note : This c631f278 ID is unique to each device, and you cannot change it. If you reflash a new sketch, this ID won't change. Once connected, the webserver is available at http://homie.config . To bypass the built-in DNS server, you can reach directly 192.168.1.1 . You can then configure the device using the Configuration API . When the device receives its configuration, it will reboot to normal mode.","title":"Connecting to the AP and configuring the device"},{"location":"2.-Getting-started/#understanding-what-happens-in-normal-mode","text":"","title":"Understanding what happens in normal mode"},{"location":"2.-Getting-started/#visual-codes","text":"When the device boots in normal mode, it will start blinking: Slowly when connecting to the Wi-Fi Faster when connecting to the MQTT broker This way, you can have a quick feedback on what's going on. If both connections are established, the LED will stay off. Note the device will also blink during the automatic reconnection, if the connection to the Wi-Fi or the MQTT broker is lost.","title":"Visual codes"},{"location":"2.-Getting-started/#under-the-hood","text":"Although the sketch looks like it does not do anything, it actually does quite a lot: It automatically connects to the Wi-Fi and MQTT broker. No more network boilerplate code It exposes the Homie device on MQTT (as devices / device ID , e.g. devices/c631f278 ). It subscribes to the special device property $ota , automatically rebooting in OTA mode if OTA is available It checks for a button press on the ESP8266, to return to configuration mode","title":"Under the hood"},{"location":"2.-Getting-started/#creating-an-useful-sketch","text":"Now that we understand how Homie for ESP8266 works, let's create an useful sketch. We want to create a smart light. #include <Homie.h> const int PIN_RELAY = 5 ; HomieNode lightNode ( \"light\" , \"switch\" ); bool lightOnHandler ( String value ) { if ( value == \"true\" ) { digitalWrite ( PIN_RELAY , HIGH ); Homie . setNodeProperty ( lightNode , \"on\" , \"true\" ); // Update the state of the light Serial . println ( \"Light is on\" ); } else if ( value == \"false\" ) { digitalWrite ( PIN_RELAY , LOW ); Homie . setNodeProperty ( lightNode , \"on\" , \"false\" ); Serial . println ( \"Light is off\" ); } else { return false ; } return true ; } void setup () { pinMode ( PIN_RELAY , OUTPUT ); digitalWrite ( PIN_RELAY , LOW ); Homie . setFirmware ( \"awesome-relay\" , \"1.0.0\" ); lightNode . subscribe ( \"on\" , lightOnHandler ); Homie . registerNode ( lightNode ); Homie . setup (); } void loop () { Homie . loop (); } Alright, step by step: We create a node with an ID of light and a type of switch with HomieNode lightNode(\"light\", \"switch\") We set the name and the version of the firmware with Homie.setFirmware(\"awesome-light\" ,\"1.0.0\"); We want our light node to subscribe to the on property. We do that with lightNode.subscribe(\"on\", lightOnHandler); . The lightOnHandler function will be called when the value of this property is changed We tell Homie for ESP8266 to expose our light node by registering it. We do this with Homie.registerNode(lightNode); In the lightOnHandler function, we want to update the state of the light node. We do this with Homie.setNodeProperty(lightNode, \"on\", \"true\"); In about thirty SLOC, we have achieved to create a smart light, without any hard-coded credentials, with automatic reconnection in case of network failure, and with OTA support. Not bad, right?","title":"Creating an useful sketch"},{"location":"2.-Getting-started/#creating-a-sensor-node","text":"In the previous example sketch, we were reacting on property changes. But what if we want, for example, to send a temperature every 5 minute? We could do this in the Arduino loop() function. But then, we would have to check if we are in normal mode, and we would have to ensure the network connection is up before sending any property. Boring. Fortunately, Homie for ESP8266 provides an easy way to do that. #include <Homie.h> const int TEMPERATURE_INTERVAL = 300 ; unsigned long lastTemperatureSent = 0 ; HomieNode temperatureNode ( \"temperature\" , \"temperature\" ); void setupHandler () { // Do what you want to prepare your sensor } void loopHandler () { if ( millis () - lastTemperatureSent >= TEMPERATURE_INTERVAL * 1000UL || lastTemperatureSent == 0 ) { float temperature = 22 ; // Fake temperature here, for the example Serial . print ( \"Temperature: \" ); Serial . print ( temperature ); Serial . println ( \" \u00b0C\" ); if ( Homie . setNodeProperty ( temperatureNode , \"temperature\" , String ( temperature ), true )) { lastTemperatureSent = millis (); } else { Serial . println ( \"Sending failed\" ); } } } void setup () { Homie . setFirmware ( \"awesome-temperature\" , \"1.0.0\" ); Homie . registerNode ( temperatureNode ); Homie . setSetupFunction ( setupHandler ); Homie . setLoopFunction ( loopHandler ); Homie . setup (); } void loop () { Homie . loop (); } The only new things here are the Homie.setSetupFunction(setupHandler); and Homie.setLoopFunction(loopHandler); calls. The setup function will be called once, when the device is in normal mode and the network connection is up. The loop function will be called everytime, when the device is in normal mode and the network connection is up. This provides a nice level of abstraction. Now that you understand the basic usage of Homie for ESP8266, you can head on to the Advanced usage page to learn about more powerful features like input handlers and the event system.","title":"Creating a sensor node"},{"location":"3.-Advanced-usage/","text":"Advanced usage \u00b6 Built-in LED \u00b6 By default, Homie for ESP8266 will blink the built-in LED to indicate its status. However, on some boards like the ESP-01, the built-in LED is actually the TX port, so it is fine if Serial is not enabled, but if you enable Serial, this is a problem. You can easily disable the built-in LED blinking. void setup () { Homie . enableBuiltInLedIndicator ( false ); // before Homie.setup() // ... } You may, instead of completely disable the LED control, set a new LED to control: void setup () { Homie . setLedPin ( 16 , HIGH ); // before Homie.setup() -- 2nd param is the state when the LED is on // ... } Change the brand \u00b6 By default, Homie for ESP8266 will spawn a Homie-XXXXXXXX AP, will connect to the MQTT broker with the Homie-XXXXXXXX client ID, etc. You might want to change the Homie text: void setup () { Homie . setBrand ( \"MyIoTSystem\" ); // before Homie.setup() // ... } Hook to Homie events \u00b6 You may want to hook to Homie events. Maybe you will want to blink a LED if the Wi-Fi connection is lost, or execute some code prior to a device reset to clear some EEPROM you're using. void onHomieEvent ( HomieEvent event ) { switch ( event ) { case HOMIE_CONFIGURATION_MODE : // Do whatever you want when configuration mode is started break ; case HOMIE_NORMAL_MODE : // Do whatever you want when normal mode is started break ; case HOMIE_OTA_MODE : // Do whatever you want when OTA mode is started break ; case HOMIE_ABOUT_TO_RESET : // Do whatever you want when the device is about to reset break ; case HOMIE_WIFI_CONNECTED : // Do whatever you want when Wi-Fi is connected in normal mode break ; case HOMIE_WIFI_DISCONNECTED : // Do whatever you want when Wi-Fi is disconnected in normal mode break ; case HOMIE_MQTT_CONNECTED : // Do whatever you want when MQTT is connected in normal mode break ; case HOMIE_MQTT_DISCONNECTED : // Do whatever you want when MQTT is disconnected in normal mode break ; } } void setup () { Homie . onEvent ( onHomieEvent ); // before Homie.setup() // ... } See the HookToEvents example for a concrete use case. Serial / Logging \u00b6 By default, Homie for ESP8266 will output a lot of useful debug messages on the Serial. You may want to disable this behavior if you want to use the Serial line for anything else. void setup () { Homie . enableLogging ( false ); // before Homie.setup() // ... } If logging is enabled Serial.begin(); will be called internally at 115 200 baud in Homie.setup() . So don't initialize the Serial line yourself. Input handlers \u00b6 There are three types of input handlers: Global input handler. This unique handler will handle every changed subscribed properties for all registered nodes bool globalInputHandler ( String node , String property , String value ) { } void setup () { Homie . setGlobalInputHandler ( globalInputHandler ); // before Homie.setup() // ... } * Node input handlers. This handler will handle every changed subscribed properties of a specific node bool nodeInputHandler ( String property , String value ) { } HomieNode node ( \"id\" , \"type\" , nodeInputHandler ); * Property input handlers. This handler will handle changes for a specific property of a specific node bool propertyInputHandler ( String value ) { } HomieNode node ( \"id\" , \"type\" ); void setup () { node . subscribe ( \"property\" , propertyInputHandler ); // before Homie.setup() // ... } You can see that input handlers return a boolean. An input handler can decide whether or not it handled the message and want to propagate it down to other input handlers. If an input handler returns true , the propagation is stopped, if it returns false , the propagation continues. The order of the propagation is global handler \u2192 node handler \u2192 property handler. For example, imagine you defined three input handlers: the global one, the node one, and the property one. If the global input handler returns false , the node input handler will be called. If the node input handler returns true , the propagation is stopped and the property input handler won't be called. HomieNode \u00b6 You might want to create a node that subscribes to all properties. Just add a fourth parameter to the HomieNode constructor, set to true : bool nodeInputHandler ( String property , String value ) { } HomieNode node ( \"id\" , \"type\" , nodeInputHandler , true ); See the LedStrip example for a concrete use case. Reset \u00b6 Resetting the device means erasing the stored configuration and rebooting from normal mode to configuration mode. By default, you can do it by pressing 5 seconds the FLASH button of your ESP8266 board. This behavior is configurable: void setup () { Homie . setResetTrigger ( 1 , LOW , 2000 ); // before Homie.setup() // ... } The device will now reset if pin 1 is LOW for 2000 ms. You can also disable completely this reset trigger: void setup () { Homie . disableResetTrigger (); // before Homie.setup() // ... } In addition, you can also provide your own function responsible for the device reset. This function will be looped: bool resetFunction () { return true ; // If true is returned, the device will reset, if false, it won't } void setup () { Homie . setResetFunction ( resetFunction ); // before Homie.setup() // ... } Sometimes, you might want to disable temporarily the ability to reset the device. For example, if your device is doing some background work like moving shutters, you will want to disable the ability to reset until the shutters are not moving anymore. Homie . setResettable ( false ); Note that if a reset is asked while resettable is set to false, the device will be flagged. In other words, when you will call Homie.setResettable(true); back, the device will immediately reset. Know if device is in normal mode \u00b6 If, for some reason, you want to run some code in the Arduino loop() function, it might be useful for you to know if the device is in normal mode and if the network connection is up. void loop () { if ( Homie . isReadyToOperate ()) { // normal mode and network connection up } else { // not in normal mode or network connection down } }","title":"Advanced usage"},{"location":"3.-Advanced-usage/#advanced-usage","text":"","title":"Advanced usage"},{"location":"3.-Advanced-usage/#built-in-led","text":"By default, Homie for ESP8266 will blink the built-in LED to indicate its status. However, on some boards like the ESP-01, the built-in LED is actually the TX port, so it is fine if Serial is not enabled, but if you enable Serial, this is a problem. You can easily disable the built-in LED blinking. void setup () { Homie . enableBuiltInLedIndicator ( false ); // before Homie.setup() // ... } You may, instead of completely disable the LED control, set a new LED to control: void setup () { Homie . setLedPin ( 16 , HIGH ); // before Homie.setup() -- 2nd param is the state when the LED is on // ... }","title":"Built-in LED"},{"location":"3.-Advanced-usage/#change-the-brand","text":"By default, Homie for ESP8266 will spawn a Homie-XXXXXXXX AP, will connect to the MQTT broker with the Homie-XXXXXXXX client ID, etc. You might want to change the Homie text: void setup () { Homie . setBrand ( \"MyIoTSystem\" ); // before Homie.setup() // ... }","title":"Change the brand"},{"location":"3.-Advanced-usage/#hook-to-homie-events","text":"You may want to hook to Homie events. Maybe you will want to blink a LED if the Wi-Fi connection is lost, or execute some code prior to a device reset to clear some EEPROM you're using. void onHomieEvent ( HomieEvent event ) { switch ( event ) { case HOMIE_CONFIGURATION_MODE : // Do whatever you want when configuration mode is started break ; case HOMIE_NORMAL_MODE : // Do whatever you want when normal mode is started break ; case HOMIE_OTA_MODE : // Do whatever you want when OTA mode is started break ; case HOMIE_ABOUT_TO_RESET : // Do whatever you want when the device is about to reset break ; case HOMIE_WIFI_CONNECTED : // Do whatever you want when Wi-Fi is connected in normal mode break ; case HOMIE_WIFI_DISCONNECTED : // Do whatever you want when Wi-Fi is disconnected in normal mode break ; case HOMIE_MQTT_CONNECTED : // Do whatever you want when MQTT is connected in normal mode break ; case HOMIE_MQTT_DISCONNECTED : // Do whatever you want when MQTT is disconnected in normal mode break ; } } void setup () { Homie . onEvent ( onHomieEvent ); // before Homie.setup() // ... } See the HookToEvents example for a concrete use case.","title":"Hook to Homie events"},{"location":"3.-Advanced-usage/#serial-logging","text":"By default, Homie for ESP8266 will output a lot of useful debug messages on the Serial. You may want to disable this behavior if you want to use the Serial line for anything else. void setup () { Homie . enableLogging ( false ); // before Homie.setup() // ... } If logging is enabled Serial.begin(); will be called internally at 115 200 baud in Homie.setup() . So don't initialize the Serial line yourself.","title":"Serial / Logging"},{"location":"3.-Advanced-usage/#input-handlers","text":"There are three types of input handlers: Global input handler. This unique handler will handle every changed subscribed properties for all registered nodes bool globalInputHandler ( String node , String property , String value ) { } void setup () { Homie . setGlobalInputHandler ( globalInputHandler ); // before Homie.setup() // ... } * Node input handlers. This handler will handle every changed subscribed properties of a specific node bool nodeInputHandler ( String property , String value ) { } HomieNode node ( \"id\" , \"type\" , nodeInputHandler ); * Property input handlers. This handler will handle changes for a specific property of a specific node bool propertyInputHandler ( String value ) { } HomieNode node ( \"id\" , \"type\" ); void setup () { node . subscribe ( \"property\" , propertyInputHandler ); // before Homie.setup() // ... } You can see that input handlers return a boolean. An input handler can decide whether or not it handled the message and want to propagate it down to other input handlers. If an input handler returns true , the propagation is stopped, if it returns false , the propagation continues. The order of the propagation is global handler \u2192 node handler \u2192 property handler. For example, imagine you defined three input handlers: the global one, the node one, and the property one. If the global input handler returns false , the node input handler will be called. If the node input handler returns true , the propagation is stopped and the property input handler won't be called.","title":"Input handlers"},{"location":"3.-Advanced-usage/#homienode","text":"You might want to create a node that subscribes to all properties. Just add a fourth parameter to the HomieNode constructor, set to true : bool nodeInputHandler ( String property , String value ) { } HomieNode node ( \"id\" , \"type\" , nodeInputHandler , true ); See the LedStrip example for a concrete use case.","title":"HomieNode"},{"location":"3.-Advanced-usage/#reset","text":"Resetting the device means erasing the stored configuration and rebooting from normal mode to configuration mode. By default, you can do it by pressing 5 seconds the FLASH button of your ESP8266 board. This behavior is configurable: void setup () { Homie . setResetTrigger ( 1 , LOW , 2000 ); // before Homie.setup() // ... } The device will now reset if pin 1 is LOW for 2000 ms. You can also disable completely this reset trigger: void setup () { Homie . disableResetTrigger (); // before Homie.setup() // ... } In addition, you can also provide your own function responsible for the device reset. This function will be looped: bool resetFunction () { return true ; // If true is returned, the device will reset, if false, it won't } void setup () { Homie . setResetFunction ( resetFunction ); // before Homie.setup() // ... } Sometimes, you might want to disable temporarily the ability to reset the device. For example, if your device is doing some background work like moving shutters, you will want to disable the ability to reset until the shutters are not moving anymore. Homie . setResettable ( false ); Note that if a reset is asked while resettable is set to false, the device will be flagged. In other words, when you will call Homie.setResettable(true); back, the device will immediately reset.","title":"Reset"},{"location":"3.-Advanced-usage/#know-if-device-is-in-normal-mode","text":"If, for some reason, you want to run some code in the Arduino loop() function, it might be useful for you to know if the device is in normal mode and if the network connection is up. void loop () { if ( Homie . isReadyToOperate ()) { // normal mode and network connection up } else { // not in normal mode or network connection down } }","title":"Know if device is in normal mode"},{"location":"4.-OTA/","text":"OTA \u00b6 Homie for ESP8266 supports OTA, if enabled in the configuration, and if a compatible OTA server is set up. It works this way: The device receives an OTA notification from the MQTT broker, as defined in the Homie convention. If the version sent by the broker is different from the one set with Homie.setFirmware() , and if OTA is enabled in the configuration, the device will be flagged to reboot to OTA mode as soon as the device will be resettable (with Homie.setResettable() ). The device boots in OTA mode The device reaches the OTA server and attempt to flash the new firmware If the OTA fails or succeed, the device reboots to normal mode Creating a compatible OTA server \u00b6 In OTA mode, the device sends a request to the host/path set in the configuration. This request contains the following headers: User-Agent : ESP8266-http-Update x-ESP8266-free-space : space available on the ESP8266 in bytes x-ESP8266-version : Device ID = Firmware name = Firmware version = OTA version target (e.g. c631f278=awesome-light=1.0.0=1.1.0 ) Your server has to parse these headers. Based on the x-ESP8266-version header, it should decide what firmware it should send to the device. If no firmware is found, or if the firmware is bigger than the x-ESP8266-free-space header content, you can abort the OTA by sending a response with a 304 error code. To actually send the firmware, you must transfer the firmware file with a 200 code. For more bulletproof updates, you can also provide in the response the MD5 of your firmware file, in the x-MD5 header. You have an example PHP in the Arduino for ESP8266 doc and a Node.js example in the homie-server project .","title":"OTA"},{"location":"4.-OTA/#ota","text":"Homie for ESP8266 supports OTA, if enabled in the configuration, and if a compatible OTA server is set up. It works this way: The device receives an OTA notification from the MQTT broker, as defined in the Homie convention. If the version sent by the broker is different from the one set with Homie.setFirmware() , and if OTA is enabled in the configuration, the device will be flagged to reboot to OTA mode as soon as the device will be resettable (with Homie.setResettable() ). The device boots in OTA mode The device reaches the OTA server and attempt to flash the new firmware If the OTA fails or succeed, the device reboots to normal mode","title":"OTA"},{"location":"4.-OTA/#creating-a-compatible-ota-server","text":"In OTA mode, the device sends a request to the host/path set in the configuration. This request contains the following headers: User-Agent : ESP8266-http-Update x-ESP8266-free-space : space available on the ESP8266 in bytes x-ESP8266-version : Device ID = Firmware name = Firmware version = OTA version target (e.g. c631f278=awesome-light=1.0.0=1.1.0 ) Your server has to parse these headers. Based on the x-ESP8266-version header, it should decide what firmware it should send to the device. If no firmware is found, or if the firmware is bigger than the x-ESP8266-free-space header content, you can abort the OTA by sending a response with a 304 error code. To actually send the firmware, you must transfer the firmware file with a 200 code. For more bulletproof updates, you can also provide in the response the MD5 of your firmware file, in the x-MD5 header. You have an example PHP in the Arduino for ESP8266 doc and a Node.js example in the homie-server project .","title":"Creating a compatible OTA server"},{"location":"5.-JSON-configuration-file/","text":"JSON configuration file \u00b6 To configure your device, you have two choices: manually flashing the configuration file to the SPIFFS at the /homie/config.json (see Uploading files to file system ), so you can bypass the configuration mode, or send it through the Configuration API . Below is the format of the JSON configuration you will have to provide: { \"name\" : \"The kitchen light\" , \"device_id\" : \"kitchen-light\" , \"wifi\" : { \"ssid\" : \"Network_1\" , \"password\" : \"I'm a Wi-Fi password!\" }, \"mqtt\" : { \"host\" : \"192.168.1.10\" , \"port\" : 1883 , \"mdns\" : \"mqtt\" , \"base_topic\" : \"devices/\" , \"auth\" : true , \"username\" : \"user\" , \"password\" : \"pass\" , \"ssl\" : true , \"fingerprint\" : \"CF 05 98 89 CA FF 8E D8 5E 5C E0 C2 E4 F7 E6 C3 C7 50 DD 5C\" }, \"ota\" : { \"enabled\" : true , \"host\" : \"192.168.1.10\" , \"port\" : 80 , \"mdns\" : \"ota\" , \"path\" : \"/custom_ota\" , \"ssl\" : true , \"fingerprint\" : \"CF 05 98 89 CA FF 8E D8 5E 5C E0 C2 E4 F7 E6 C3 C7 50 DD 5C\" } } The above JSON contains every field that can be customized. Here are the rules: name , wifi.ssid , wifi.password , mqtt.host (or mqtt.mdns ) and ota.enabled are mandatory wifi.password can be \"\" if connecting to an open network If mqtt.auth is true , mqtt.username and mqtt.password must be provided If a mdns field is set, the device will ignore the host and port fields and query for the corresponding mDNS service and get the first IP and port found Default values if not provided: device_id : the hardware device ID (eg. 1a2b3c4d ) mqtt.port : 1883 mqtt.base_topic : devices/ mqtt.auth : false mqtt.ssl : false ota.host : same as mqtt.host ota.port : 80 ota.path : /ota ota.ssl : false host fields can be either an IP or an hostname. The SSL fingerprints can be of the following format: CF 05 98 89 CA FF 8E D8 5E 5C E0 C2 E4 F7 E6 C3 C7 50 DD 5C CF : 05 : 98 : 89 : CA : FF : 8 E : D8 : 5 E : 5 C : E0 : C2 : E4 : F7 : E6 : C3 : C7 : 50 : DD : 5 C cf 05 98 89 ca ff 8e d8 5e 5c e0 c2 e4 f7 e6 c3 c7 50 dd 5c cf : 05 : 98 : 89 : ca : ff : 8 e : d8 : 5 e : 5 c : e0 : c2 : e4 : f7 : e6 : c3 : c7 : 50 : dd : 5 c","title":"JSON configuration file"},{"location":"5.-JSON-configuration-file/#json-configuration-file","text":"To configure your device, you have two choices: manually flashing the configuration file to the SPIFFS at the /homie/config.json (see Uploading files to file system ), so you can bypass the configuration mode, or send it through the Configuration API . Below is the format of the JSON configuration you will have to provide: { \"name\" : \"The kitchen light\" , \"device_id\" : \"kitchen-light\" , \"wifi\" : { \"ssid\" : \"Network_1\" , \"password\" : \"I'm a Wi-Fi password!\" }, \"mqtt\" : { \"host\" : \"192.168.1.10\" , \"port\" : 1883 , \"mdns\" : \"mqtt\" , \"base_topic\" : \"devices/\" , \"auth\" : true , \"username\" : \"user\" , \"password\" : \"pass\" , \"ssl\" : true , \"fingerprint\" : \"CF 05 98 89 CA FF 8E D8 5E 5C E0 C2 E4 F7 E6 C3 C7 50 DD 5C\" }, \"ota\" : { \"enabled\" : true , \"host\" : \"192.168.1.10\" , \"port\" : 80 , \"mdns\" : \"ota\" , \"path\" : \"/custom_ota\" , \"ssl\" : true , \"fingerprint\" : \"CF 05 98 89 CA FF 8E D8 5E 5C E0 C2 E4 F7 E6 C3 C7 50 DD 5C\" } } The above JSON contains every field that can be customized. Here are the rules: name , wifi.ssid , wifi.password , mqtt.host (or mqtt.mdns ) and ota.enabled are mandatory wifi.password can be \"\" if connecting to an open network If mqtt.auth is true , mqtt.username and mqtt.password must be provided If a mdns field is set, the device will ignore the host and port fields and query for the corresponding mDNS service and get the first IP and port found Default values if not provided: device_id : the hardware device ID (eg. 1a2b3c4d ) mqtt.port : 1883 mqtt.base_topic : devices/ mqtt.auth : false mqtt.ssl : false ota.host : same as mqtt.host ota.port : 80 ota.path : /ota ota.ssl : false host fields can be either an IP or an hostname. The SSL fingerprints can be of the following format: CF 05 98 89 CA FF 8E D8 5E 5C E0 C2 E4 F7 E6 C3 C7 50 DD 5C CF : 05 : 98 : 89 : CA : FF : 8 E : D8 : 5 E : 5 C : E0 : C2 : E4 : F7 : E6 : C3 : C7 : 50 : DD : 5 C cf 05 98 89 ca ff 8e d8 5e 5c e0 c2 e4 f7 e6 c3 c7 50 dd 5c cf : 05 : 98 : 89 : ca : ff : 8 e : d8 : 5 e : 5 c : e0 : c2 : e4 : f7 : e6 : c3 : c7 : 50 : dd : 5 c","title":"JSON configuration file"},{"location":"6.-Configuration-API/","text":"Configuration API \u00b6 When in configuration mode, the device exposes a JSON API to send the configuration to it. When you send a valid configuration to the /config endpoint, the configuration file is stored in the file system at /homie/config.json . If you don't want to mess with JSON, you have a Web UI / app available: * At http://marvinroger.github.io/homie-esp8266 * As an Android app Quick instructions to use the Web UI / app : Open the Web UI / app Disconnect from your current Wi-Fi AP, and connect to the Homie-xxxxxxxx AP spawned in configuration mode Follow the instructions You can see the sources of the Web UI here and the built version here Alternatively, you can use this curl command to send the config to the device: curl -X PUT http://homie.config/config --header \"Content-Type: application/json\" -d @config.json This will send the ./config.json file to the device. Error handling \u00b6 When everything went fine, a 200 OK HTTP code is returned. If anything goes wrong, a return code != 200 will be returned, with a JSON error field indicating the error. API endpoints \u00b6 GET /heart \u00b6 This is useful to ensure we are connected to the device AP. Response \u00b6 200 OK (application/json) { \"heart\" : \"beat\" } GET /device-info \u00b6 Get some information on the device. Response \u00b6 200 OK (application/json) { \"device_id\" : \"52a8fa5d\" , \"homie_version\" : \"1.0.0\" , \"firmware\" : { \"name\" : \"awesome-device\" , \"version\" : \"1.0.0\" }, \"nodes\" : [ { \"id\" : \"light\" , \"type\" : \"light\" } ] } GET /networks \u00b6 Retrieve the Wi-Fi networks the device can see. Response \u00b6 In case of success: 200 OK (application/json) { \"networks\" : [ { \"ssid\" : \"Network_2\" , \"rssi\" : -82 , \"encryption\" : \"wep\" }, { \"ssid\" : \"Network_1\" , \"rssi\" : -57 , \"encryption\" : \"wpa\" }, { \"ssid\" : \"Network_3\" , \"rssi\" : -65 , \"encryption\" : \"wpa2\" }, { \"ssid\" : \"Network_5\" , \"rssi\" : -94 , \"encryption\" : \"none\" }, { \"ssid\" : \"Network_4\" , \"rssi\" : -89 , \"encryption\" : \"auto\" } ] } In case the initial Wi-Fi scan is not finished on the device: 503 Service Unavailable (application/json) { \"error\" : \"Initial Wi-Fi scan not finished yet\" } PUT /config \u00b6 Save the config to the device. Request body \u00b6 (application/json) See JSON configuration file . Response \u00b6 In case of success: 200 OK (application/json) { \"success\" : true } In case of error in the payload: 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" } In case the device already received a valid configuration and is waiting for reboot: 403 Forbidden (application/json) { \"success\" : false , \"error\" : \"Device already configured\" }","title":"Configuration API"},{"location":"6.-Configuration-API/#configuration-api","text":"When in configuration mode, the device exposes a JSON API to send the configuration to it. When you send a valid configuration to the /config endpoint, the configuration file is stored in the file system at /homie/config.json . If you don't want to mess with JSON, you have a Web UI / app available: * At http://marvinroger.github.io/homie-esp8266 * As an Android app Quick instructions to use the Web UI / app : Open the Web UI / app Disconnect from your current Wi-Fi AP, and connect to the Homie-xxxxxxxx AP spawned in configuration mode Follow the instructions You can see the sources of the Web UI here and the built version here Alternatively, you can use this curl command to send the config to the device: curl -X PUT http://homie.config/config --header \"Content-Type: application/json\" -d @config.json This will send the ./config.json file to the device.","title":"Configuration API"},{"location":"6.-Configuration-API/#error-handling","text":"When everything went fine, a 200 OK HTTP code is returned. If anything goes wrong, a return code != 200 will be returned, with a JSON error field indicating the error.","title":"Error handling"},{"location":"6.-Configuration-API/#api-endpoints","text":"","title":"API endpoints"},{"location":"6.-Configuration-API/#get-heart","text":"This is useful to ensure we are connected to the device AP.","title":"GET /heart"},{"location":"6.-Configuration-API/#response","text":"200 OK (application/json) { \"heart\" : \"beat\" }","title":"Response"},{"location":"6.-Configuration-API/#get-device-info","text":"Get some information on the device.","title":"GET /device-info"},{"location":"6.-Configuration-API/#response_1","text":"200 OK (application/json) { \"device_id\" : \"52a8fa5d\" , \"homie_version\" : \"1.0.0\" , \"firmware\" : { \"name\" : \"awesome-device\" , \"version\" : \"1.0.0\" }, \"nodes\" : [ { \"id\" : \"light\" , \"type\" : \"light\" } ] }","title":"Response"},{"location":"6.-Configuration-API/#get-networks","text":"Retrieve the Wi-Fi networks the device can see.","title":"GET /networks"},{"location":"6.-Configuration-API/#response_2","text":"In case of success: 200 OK (application/json) { \"networks\" : [ { \"ssid\" : \"Network_2\" , \"rssi\" : -82 , \"encryption\" : \"wep\" }, { \"ssid\" : \"Network_1\" , \"rssi\" : -57 , \"encryption\" : \"wpa\" }, { \"ssid\" : \"Network_3\" , \"rssi\" : -65 , \"encryption\" : \"wpa2\" }, { \"ssid\" : \"Network_5\" , \"rssi\" : -94 , \"encryption\" : \"none\" }, { \"ssid\" : \"Network_4\" , \"rssi\" : -89 , \"encryption\" : \"auto\" } ] } In case the initial Wi-Fi scan is not finished on the device: 503 Service Unavailable (application/json) { \"error\" : \"Initial Wi-Fi scan not finished yet\" }","title":"Response"},{"location":"6.-Configuration-API/#put-config","text":"Save the config to the device.","title":"PUT /config"},{"location":"6.-Configuration-API/#request-body","text":"(application/json) See JSON configuration file .","title":"Request body"},{"location":"6.-Configuration-API/#response_3","text":"In case of success: 200 OK (application/json) { \"success\" : true } In case of error in the payload: 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" } In case the device already received a valid configuration and is waiting for reboot: 403 Forbidden (application/json) { \"success\" : false , \"error\" : \"Device already configured\" }","title":"Response"},{"location":"7.-API-reference/","text":"API reference \u00b6 Homie object \u00b6 You don't have to instantiate an Homie instance, it is done internally. void Homie.setup () \u00b6 Setup Homie. Must be called once in setup() . void Homie.loop () \u00b6 Handle Homie work. Must be called in loop() . void Homie.enableLogging (bool enable ) \u00b6 Enable or disable Homie Serial logging. If logging is enabled, Serial.begin(115200) will be called internally. enable : Whether or not to enable logging. By default, logging is enabled void Homie.enableBuiltInLedIndicator (bool enable ) \u00b6 Enable or disable the built-in LED to indicate the Homie state. enable : Whether or not to enable built-in LED. By default, it is enabled void Homie.setLedPin (unsigned char pin , unsigned char on ) \u00b6 Set pin of the LED to control. pin : LED to control on : state when the light is on (HIGH or LOW) void Homie.setBrand (const char* name ) \u00b6 Set the brand of the device, used in the configuration AP, the device hostname and the MQTT client ID. name : Name of the brand. Default value is Homie void Homie.setFirmware (const char* name , const char* version ) \u00b6 Set the name and version of the firmware. This is useful for OTA, as Homie will check against the server if there is a newer version. name : Name of the firmware. Default value is undefined version : Version of the firmware. Default value is undefined void Homie.registerNode (HomieNode node ) \u00b6 Register a node. node : node to register void Homie.setGlobalInputHandler (std::function handler ) \u00b6 Set input handler for subscribed properties. handler : Global input handler node : Name of the node getting updated property : Property of the node getting updated value : Value of the new property void Homie.onEvent (std::function callback ) \u00b6 Set the event handler. Useful if you want to hook to Homie events. callback : Event handler void Homie.setResetTrigger (unsigned char pin , unsigned char state , unsigned int time ) \u00b6 Set the reset trigger. By default, the device will reset when pin 0 is LOW for 5000 ms. pin : Pin of the reset trigger state : Reset when the pin reaches this state for the given time time : Time necessary to reset void Homie.disableResetTrigger () \u00b6 Disable the reset trigger. void Homie.setResetFunction (std::function callback ) \u00b6 Set the reset function. This is a function that is going to be called at each loop iteration, which can trigger a device reset. If the function returns true, the device resets. Else, it does not. callback : Reset function void Homie.setSetupFunction (std::function callback ) \u00b6 You can provide the function that will be called when operating in normal mode. callback : Setup function void Homie.setLoopFunction (std::function callback ) \u00b6 You can provide the function that will be looped in normal mode. callback : Loop function void Homie.setNodeProperty (HomieNode node , String property , String value , bool retained = true) \u00b6 Using this function, you can set the value of a node property, like a temperature for example. node : HomieNode instance on which to set the property on property : Property to send value : Payload retained : Optional. Should the MQTT broker retain this value, or is it a one-shot value? void Homie.setResettable (bool resettable ) \u00b6 Is the device resettable? This is useful at runtime, because you might want the device not to be resettable when you have another library that is doing some unfinished work, like moving shutters for example. resettable : Is the device resettable? Default value is true bool Homie.isReadyToOperate () \u00b6 Is the device in normal mode, configured and connected? You should not need this function. But maybe you will. HomieNode object \u00b6 void HomieNode (const char* id , const char* type , std::function handler = , bool subscribeToAll = false) \u00b6 Constructor of a HomieNode object. id : ID of the node type : Type of the node handler : Optional. Input handler of the node subscribeToAll : Optional. Whether or not to call the handler for every properties, even the ones not registered void .subscribe (const char* property , std::function handler ) = ) \u00b6 Subscribes the node to the given property. property : Property to subscribe to handler : Optional. Input handler of the property of the node","title":"API reference"},{"location":"7.-API-reference/#api-reference","text":"","title":"API reference"},{"location":"7.-API-reference/#homie-object","text":"You don't have to instantiate an Homie instance, it is done internally.","title":"Homie object"},{"location":"7.-API-reference/#void-homiesetup","text":"Setup Homie. Must be called once in setup() .","title":"void Homie.setup ()"},{"location":"7.-API-reference/#void-homieloop","text":"Handle Homie work. Must be called in loop() .","title":"void Homie.loop ()"},{"location":"7.-API-reference/#void-homieenablelogging-bool-enable","text":"Enable or disable Homie Serial logging. If logging is enabled, Serial.begin(115200) will be called internally. enable : Whether or not to enable logging. By default, logging is enabled","title":"void Homie.enableLogging (bool enable)"},{"location":"7.-API-reference/#void-homieenablebuiltinledindicator-bool-enable","text":"Enable or disable the built-in LED to indicate the Homie state. enable : Whether or not to enable built-in LED. By default, it is enabled","title":"void Homie.enableBuiltInLedIndicator (bool enable)"},{"location":"7.-API-reference/#void-homiesetledpin-unsigned-char-pin-unsigned-char-on","text":"Set pin of the LED to control. pin : LED to control on : state when the light is on (HIGH or LOW)","title":"void Homie.setLedPin (unsigned char pin, unsigned char on)"},{"location":"7.-API-reference/#void-homiesetbrand-const-char42-name","text":"Set the brand of the device, used in the configuration AP, the device hostname and the MQTT client ID. name : Name of the brand. Default value is Homie","title":"void Homie.setBrand (const char* name)"},{"location":"7.-API-reference/#void-homiesetfirmware-const-char42-name-const-char42-version","text":"Set the name and version of the firmware. This is useful for OTA, as Homie will check against the server if there is a newer version. name : Name of the firmware. Default value is undefined version : Version of the firmware. Default value is undefined","title":"void Homie.setFirmware (const char* name, const char* version)"},{"location":"7.-API-reference/#void-homieregisternode-homienode-node","text":"Register a node. node : node to register","title":"void Homie.registerNode (HomieNode node)"},{"location":"7.-API-reference/#void-homiesetglobalinputhandler-stdfunction-handler","text":"Set input handler for subscribed properties. handler : Global input handler node : Name of the node getting updated property : Property of the node getting updated value : Value of the new property","title":"void Homie.setGlobalInputHandler (std::function handler)"},{"location":"7.-API-reference/#void-homieonevent-stdfunction-callback","text":"Set the event handler. Useful if you want to hook to Homie events. callback : Event handler","title":"void Homie.onEvent (std::function callback)"},{"location":"7.-API-reference/#void-homiesetresettrigger-unsigned-char-pin-unsigned-char-state-unsigned-int-time","text":"Set the reset trigger. By default, the device will reset when pin 0 is LOW for 5000 ms. pin : Pin of the reset trigger state : Reset when the pin reaches this state for the given time time : Time necessary to reset","title":"void Homie.setResetTrigger (unsigned char pin, unsigned char state, unsigned int time)"},{"location":"7.-API-reference/#void-homiedisableresettrigger","text":"Disable the reset trigger.","title":"void Homie.disableResetTrigger ()"},{"location":"7.-API-reference/#void-homiesetresetfunction-stdfunction-callback","text":"Set the reset function. This is a function that is going to be called at each loop iteration, which can trigger a device reset. If the function returns true, the device resets. Else, it does not. callback : Reset function","title":"void Homie.setResetFunction (std::function callback)"},{"location":"7.-API-reference/#void-homiesetsetupfunction-stdfunction-callback","text":"You can provide the function that will be called when operating in normal mode. callback : Setup function","title":"void Homie.setSetupFunction (std::function callback)"},{"location":"7.-API-reference/#void-homiesetloopfunction-stdfunction-callback","text":"You can provide the function that will be looped in normal mode. callback : Loop function","title":"void Homie.setLoopFunction (std::function callback)"},{"location":"7.-API-reference/#void-homiesetnodeproperty-homienode-node-string-property-string-value-bool-retained-true","text":"Using this function, you can set the value of a node property, like a temperature for example. node : HomieNode instance on which to set the property on property : Property to send value : Payload retained : Optional. Should the MQTT broker retain this value, or is it a one-shot value?","title":"void Homie.setNodeProperty (HomieNode node, String property, String value, bool retained = true)"},{"location":"7.-API-reference/#void-homiesetresettable-bool-resettable","text":"Is the device resettable? This is useful at runtime, because you might want the device not to be resettable when you have another library that is doing some unfinished work, like moving shutters for example. resettable : Is the device resettable? Default value is true","title":"void Homie.setResettable (bool resettable)"},{"location":"7.-API-reference/#bool-homieisreadytooperate","text":"Is the device in normal mode, configured and connected? You should not need this function. But maybe you will.","title":"bool Homie.isReadyToOperate ()"},{"location":"7.-API-reference/#homienode-object","text":"","title":"HomieNode object"},{"location":"7.-API-reference/#void-homienode-const-char42-id-const-char42-type-stdfunction-handler-bool-subscribetoall-false","text":"Constructor of a HomieNode object. id : ID of the node type : Type of the node handler : Optional. Input handler of the node subscribeToAll : Optional. Whether or not to call the handler for every properties, even the ones not registered","title":"void HomieNode (const char* id, const char* type, std::function handler = , bool subscribeToAll = false)"},{"location":"7.-API-reference/#void-subscribe-const-char42-property-stdfunction-handler","text":"Subscribes the node to the given property. property : Property to subscribe to handler : Optional. Input handler of the property of the node","title":"void .subscribe (const char* property, std::function handler) = )"},{"location":"8.-Limitations-and-known-issues/","text":"Limitations and known issues \u00b6 Blocking Homie code \u00b6 In configuration and normal modes, Homie for ESP8266 code is designed to be non-blocking, so that you can do other tasks in the main loop() . However, the connection to the MQTT broker is blocking during ~5 seconds in case the server is unreachable. This is an Arduino for ESP8266 limitation, and we can't do anything on our side to solve this issue, not even a timeout. The OTA mode is blocking for obvious reason. SSL fingerprint checking \u00b6 Adding a TLS fingerprint effectively pins the device to a particular certificate. Furthermore, as currently implemented by the ESP8266 WifiSecureClient , both mqtt.host and ota.host are verified against the server certificate's common name (CN) in the certificate subject or in the SANs (subjectAlternateName) contained in it, but not in their IP addresses. For example, if the certificate used by your server looks like this: Subject : CN = tiggr . example . org , OU = generate - CA / emailAddress = nobody @ example . net ... X509v3 Subject Alternative Name : IP Address : 192.168 . 1.10 , DNS : broker . example . org Enabling fingerprint in Homie will work only if host is set to tiggr.example.org or broker.example.org and the correct fingerprint is used; setting host to the IP address will cause fingerprint verification to fail. ADC readings \u00b6 This is a known esp8266/Arduino issue that polling analogRead() too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms.","title":"Limitations and known issues"},{"location":"8.-Limitations-and-known-issues/#limitations-and-known-issues","text":"","title":"Limitations and known issues"},{"location":"8.-Limitations-and-known-issues/#blocking-homie-code","text":"In configuration and normal modes, Homie for ESP8266 code is designed to be non-blocking, so that you can do other tasks in the main loop() . However, the connection to the MQTT broker is blocking during ~5 seconds in case the server is unreachable. This is an Arduino for ESP8266 limitation, and we can't do anything on our side to solve this issue, not even a timeout. The OTA mode is blocking for obvious reason.","title":"Blocking Homie code"},{"location":"8.-Limitations-and-known-issues/#ssl-fingerprint-checking","text":"Adding a TLS fingerprint effectively pins the device to a particular certificate. Furthermore, as currently implemented by the ESP8266 WifiSecureClient , both mqtt.host and ota.host are verified against the server certificate's common name (CN) in the certificate subject or in the SANs (subjectAlternateName) contained in it, but not in their IP addresses. For example, if the certificate used by your server looks like this: Subject : CN = tiggr . example . org , OU = generate - CA / emailAddress = nobody @ example . net ... X509v3 Subject Alternative Name : IP Address : 192.168 . 1.10 , DNS : broker . example . org Enabling fingerprint in Homie will work only if host is set to tiggr.example.org or broker.example.org and the correct fingerprint is used; setting host to the IP address will cause fingerprint verification to fail.","title":"SSL fingerprint checking"},{"location":"8.-Limitations-and-known-issues/#adc-readings","text":"This is a known esp8266/Arduino issue that polling analogRead() too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms.","title":"ADC readings"},{"location":"9.-Troubleshooting/","text":"Troubleshooting \u00b6 1. I see some garbage on the Serial monitor? \u00b6 You are probably using a generic ESP8266. The problem with these modules is the built-in LED is tied to the serial line. You can do two things: Disable the serial logging, to have the LED working: void setup () { Homie . enableLogging ( false ); // before Homie.setup() // ... } * Disable the the LED blinking, to have the serial line working: void setup () { Homie . enableBuiltInLedIndicator ( false ); // before Homie.setup() // ... } 2. I see an abort message on the Serial monitor? \u00b6 abort() is called by Homie for ESP8266 when the framework is used in a bad way. The possible causes are: You are calling a function that is meant to be called before Homie.setup() , after Homie.setup() One of the string you've used (in setFirmware() , subscribe() , etc.) is too long. Check the Limits.hpp file to see the max length possible for each string. 3. The network is completely unstable... What's going on? \u00b6 The framework needs to work continuously (ie. Homie.loop() needs to be called very frequently). In other words, don't use delay() (see avoid delay ) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with analogRead() , see Limitations and known issues#adc-readings . 4. My device resets itself without me doing anything? \u00b6 You have probably connected a sensor to the default reset pin of the framework (D3 on NodeMCU, GPIO0 on other boards). See Advanced usage#reset .","title":"Troubleshooting"},{"location":"9.-Troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"9.-Troubleshooting/#1-i-see-some-garbage-on-the-serial-monitor","text":"You are probably using a generic ESP8266. The problem with these modules is the built-in LED is tied to the serial line. You can do two things: Disable the serial logging, to have the LED working: void setup () { Homie . enableLogging ( false ); // before Homie.setup() // ... } * Disable the the LED blinking, to have the serial line working: void setup () { Homie . enableBuiltInLedIndicator ( false ); // before Homie.setup() // ... }","title":"1. I see some garbage on the Serial monitor?"},{"location":"9.-Troubleshooting/#2-i-see-an-abort-message-on-the-serial-monitor","text":"abort() is called by Homie for ESP8266 when the framework is used in a bad way. The possible causes are: You are calling a function that is meant to be called before Homie.setup() , after Homie.setup() One of the string you've used (in setFirmware() , subscribe() , etc.) is too long. Check the Limits.hpp file to see the max length possible for each string.","title":"2. I see an abort message on the Serial monitor?"},{"location":"9.-Troubleshooting/#3-the-network-is-completely-unstable-whats-going-on","text":"The framework needs to work continuously (ie. Homie.loop() needs to be called very frequently). In other words, don't use delay() (see avoid delay ) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with analogRead() , see Limitations and known issues#adc-readings .","title":"3. The network is completely unstable... What's going on?"},{"location":"9.-Troubleshooting/#4-my-device-resets-itself-without-me-doing-anything","text":"You have probably connected a sensor to the default reset pin of the framework (D3 on NodeMCU, GPIO0 on other boards). See Advanced usage#reset .","title":"4. My device resets itself without me doing anything?"}]}