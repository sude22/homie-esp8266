{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome on the Homie for ESP8266 docs.","title":"Welcome"},{"location":"advanced-usage/branding/","text":"By default, Homie for ESP8266 will spawn an Homie-xxxxxxxxxxxx AP and will connect to the MQTT broker with the Homie-xxxxxxxxxxxx client ID. You might want to change the Homie text: void setup () { Homie_setBrand ( \"MyIoTSystem\" ); // before Homie.setup() // ... }","title":"Branding"},{"location":"advanced-usage/broadcast/","text":"Your device can react to Homie broadcasts. To do that, you can use a broadcast handler: bool broadcastHandler ( const String & level , const String & value ) { Serial << \"Received broadcast level \" << level << \": \" << value << endl ; return true ; } void setup () { Homie . setBroadcastHandler ( broadcastHandler ); // before Homie.setup() // ... }","title":"Broadcast"},{"location":"advanced-usage/built-in-led/","text":"By default, Homie for ESP8266 will blink the built-in LED to indicate its status. Note it does not indicate activity, only the status of the device (in configuration mode, connecting to Wi-Fi or connecting to MQTT), see Getting started for more information. However, on some boards like the ESP-01, the built-in LED is actually the TX port, so it is fine if Serial is not enabled, but if you enable Serial, this is a problem. You can easily disable the built-in LED blinking. void setup () { Homie . disableLedFeedback (); // before Homie.setup() // ... } You may, instead of completely disable the LED control, set a new LED to control: void setup () { Homie . setLedPin ( 16 , HIGH ); // before Homie.setup() -- 2nd param is the state of the pin when the LED is o // ... }","title":"Built-in LED"},{"location":"advanced-usage/custom-settings/","text":"Homie for ESP8266 lets you implement custom settings that can be set from the JSON configuration file and the Configuration API. Below is an example of how to use this feature: HomieSetting < long > percentageSetting ( \"percentage\" , \"A simple percentage\" ); // id, description void setup () { percentageSetting . setDefaultValue ( 50 ). setValidator ([] ( long candidate ) { return ( candidate >= 0 ) && ( candidate <= 100 ); }); Homie . setup (); } An HomieSetting instance can be of the following types: Type Value bool true or false long An integer from -2,147,483,648 to 2,147,483,647 double A floating number that can fit into a real64_t const char* Any string By default, a setting is mandatory (you have to set it in the configuration file). If you give it a default value with setDefaultValue() , the setting becomes optional. You can validate a setting by giving a validator function to setValidator() . To get the setting from your code, use get() . To get whether the value returned is the optional one or the one provided, use wasProvided() . For this example, if you want to provide the percentage setting, you will have to put in your configuration file: { \"settings\" : { \"percentage\" : 75 } } See the following example for a concrete use case: CustomSettings.ino","title":"Custom settings"},{"location":"advanced-usage/deep-sleep/","text":"Before deep sleeping, you will want to ensure that all messages are sent, including the $online \u2192 false . To do that, you can call Homie.prepareToSleep() . This will disconnect everything cleanly, so that you can call ESP.deepSleep() . #include <Homie.h> void onHomieEvent ( const HomieEvent & event ) { switch ( event . type ) { case HomieEventType :: MQTT_READY : Homie . getLogger () << \"MQTT connected, preparing for deep sleep...\" << endl ; Homie . prepareToSleep (); break ; case HomieEventType :: READY_TO_SLEEP : Homie . getLogger () << \"Ready to sleep\" << endl ; Homie . doDeepSleep (); break ; } } void setup () { Serial . begin ( 115200 ); Serial << endl << endl ; Homie . onEvent ( onHomieEvent ); Homie . setup (); } void loop () { Homie . loop (); }","title":"Deep sleep"},{"location":"advanced-usage/events/","text":"You may want to hook to Homie events. Maybe you will want to control an RGB LED if the Wi-Fi connection is lost, or execute some code prior to a device reset, for example to clear some EEPROM you're using: void onHomieEvent ( const HomieEvent & event ) { switch ( event . type ) { case HomieEventType :: STANDALONE_MODE : // Do whatever you want when standalone mode is started break ; case HomieEventType :: CONFIGURATION_MODE : // Do whatever you want when configuration mode is started break ; case HomieEventType :: NORMAL_MODE : // Do whatever you want when normal mode is started break ; case HomieEventType :: OTA_STARTED : // Do whatever you want when OTA is started break ; case HomieEventType :: OTA_PROGRESS : // Do whatever you want when OTA is in progress // You can use event.sizeDone and event.sizeTotal break ; case HomieEventType :: OTA_FAILED : // Do whatever you want when OTA is failed break ; case HomieEventType :: OTA_SUCCESSFUL : // Do whatever you want when OTA is successful break ; case HomieEventType :: ABOUT_TO_RESET : // Do whatever you want when the device is about to reset break ; case HomieEventType :: WIFI_CONNECTED : // Do whatever you want when Wi-Fi is connected in normal mode // You can use event.ip, event.gateway, event.mask break ; case HomieEventType :: WIFI_DISCONNECTED : // Do whatever you want when Wi-Fi is disconnected in normal mode // You can use event.wifiReason break ; case HomieEventType :: MQTT_READY : // Do whatever you want when MQTT is connected in normal mode break ; case HomieEventType :: MQTT_DISCONNECTED : // Do whatever you want when MQTT is disconnected in normal mode // You can use event.mqttReason break ; case HomieEventType :: MQTT_PACKET_ACKNOWLEDGED : // Do whatever you want when an MQTT packet with QoS > 0 is acknowledged by the broker // You can use event.packetId break ; case HomieEventType :: READY_TO_SLEEP : // After you've called `prepareToSleep()`, the event is triggered when MQTT is disconnected break ; } } void setup () { Homie . onEvent ( onHomieEvent ); // before Homie.setup() // ... } See the following example for a concrete use case: HookToEvents.ino","title":"Events"},{"location":"advanced-usage/input-handlers/","text":"There are four types of input handlers: Global input handler. This unique handler will handle every changed settable properties for all nodes bool globalInputHandler ( const HomieNode & node , const String & property , const HomieRange & range , const String & value ) { } void setup () { Homie . setGlobalInputHandler ( globalInputHandler ); // before Homie.setup() // ... } Node input handlers. This handler will handle every changed settable properties of a specific node bool nodeInputHandler ( const String & property , const HomieRange & range , const String & value ) { } HomieNode node ( \"id\" , \"type\" , nodeInputHandler ); Virtual callback from node input handler You can create your own class derived from HomieNode that implements the virtual method bool HomieNode::handleInput(const String& property, const String& value) . The default node input handler then automatically calls your callback. class RelaisNode : public HomieNode { public : RelaisNode () : HomieNode ( \"Relais\" , \"switch8\" ); protected : virtual bool handleInput ( const String & property , const HomieRange & range , const String & value ) { } }; Property input handlers. This handler will handle changes for a specific settable property of a specific node bool propertyInputHandler ( const HomieRange & range , const String & value ) { } HomieNode node ( \"id\" , \"type\" ); void setup () { node . advertise ( \"property\" ). settable ( propertyInputHandler ); // before Homie.setup() // ... } You can see that input handlers return a boolean. An input handler can decide whether or not it handled the message and want to propagate it down to other input handlers. If an input handler returns true , the propagation is stopped, if it returns false , the propagation continues. The order of propagation is global handler \u2192 node handler \u2192 property handler. For example, imagine you defined three input handlers: the global one, the node one, and the property one. If the global input handler returns false , the node input handler will be called. If the node input handler returns true , the propagation is stopped and the property input handler won't be called. You can think of it as middlewares. Warning Homie uses ESPAsyncTCP for network communication that make uses of asynchronous callback from the ESP8266 framework for incoming network packets. Thus the input handler runs in a different task than the loopHandler() . So keep in mind that the network task may interrupt your loop at any time.","title":"Input handlers"},{"location":"advanced-usage/logging/","text":"By default, Homie for ESP8266 will output a lot of useful debug messages on the Serial. You may want to disable this behavior if you want to use the Serial line for anything else. void setup () { Homie . disableLogging (); // before Homie.setup() // ... } Warning It's up to you to call Serial.begin(); , whether logging is enabled or not. You can also change the Print instance to log to: void setup () { Homie . setLoggingPrinter ( & Serial2 ); // before Homie.setup() // ... } You can use the logger from your code with the getLogger() client: Homie . getLogger () << \"Hey!\" << endl ;","title":"Logging"},{"location":"advanced-usage/magic-bytes/","text":"Homie for ESP8266 firmwares contain magic bytes allowing you to check if a firmware is actually an Homie for ESP8266 firmware, and if so, to get the name, the version and the brand of the firmware. You might be wondering why Homie_setFirmware() instead of Homie.setFirmware() , this is because we use special macros to embed the magic bytes. Values are encoded as such within the firmware binary: Type Left boundary Value Right boundary Homie magic bytes None 0x25 0x48 0x4F 0x4D 0x49 0x45 0x5F 0x45 0x53 0x50 0x38 0x32 0x36 0x36 0x5F 0x46 0x57 0x25 None Firmware name 0xBF 0x84 0xE4 0x13 0x54 actual firmware name 0x93 0x44 0x6B 0xA7 0x75 Firmware version 0x6A 0x3F 0x3E 0x0E 0xE1 actual firmware version 0xB0 0x30 0x48 0xD4 0x1A Firmware brand (only present if Homie_setBrand() called, Homie otherwise) 0xFB 0x2A 0xF5 0x68 0xC0 actual firmware brand 0x6E 0x2F 0x0F 0xEB 0x2D See the following script for a concrete use case: firmware_parser.py","title":"Magic bytes"},{"location":"advanced-usage/miscellaneous/","text":"Know if the device is configured / connected \u00b6 If, for some reason, you want to run some code in the Arduino loop() function, it might be useful for you to know if the device is in configured (so in normal mode) and if the network connection is up. void loop () { if ( Homie . isConfigured ()) { // The device is configured, in normal mode if ( Homie . isConnected ()) { // The device is connected } else { // The device is not connected } } else { // The device is not configured, in either configuration or standalone mode } } Get access to the configuration \u00b6 You can get access to the configuration of the device. The representation of the configuration is: struct ConfigStruct { char * name ; char * deviceId ; struct WiFi { char * ssid ; char * password ; } wifi ; struct MQTT { struct Server { char * host ; uint16_t port ; } server ; char * baseTopic ; bool auth ; char * username ; char * password ; } mqtt ; struct OTA { bool enabled ; } ota ; }; For example, to access the Wi-Fi SSID, you would do: Homie . getConfiguration (). wifi . ssid ; Get access to the MQTT client \u00b6 You can get access to the underlying MQTT client. For example, to disconnect from the broker: Homie . getMqttClient (). disconnect ();","title":"Miscellaneous"},{"location":"advanced-usage/miscellaneous/#know-if-the-device-is-configured-connected","text":"If, for some reason, you want to run some code in the Arduino loop() function, it might be useful for you to know if the device is in configured (so in normal mode) and if the network connection is up. void loop () { if ( Homie . isConfigured ()) { // The device is configured, in normal mode if ( Homie . isConnected ()) { // The device is connected } else { // The device is not connected } } else { // The device is not configured, in either configuration or standalone mode } }","title":"Know if the device is configured / connected"},{"location":"advanced-usage/miscellaneous/#get-access-to-the-configuration","text":"You can get access to the configuration of the device. The representation of the configuration is: struct ConfigStruct { char * name ; char * deviceId ; struct WiFi { char * ssid ; char * password ; } wifi ; struct MQTT { struct Server { char * host ; uint16_t port ; } server ; char * baseTopic ; bool auth ; char * username ; char * password ; } mqtt ; struct OTA { bool enabled ; } ota ; }; For example, to access the Wi-Fi SSID, you would do: Homie . getConfiguration (). wifi . ssid ;","title":"Get access to the configuration"},{"location":"advanced-usage/miscellaneous/#get-access-to-the-mqtt-client","text":"You can get access to the underlying MQTT client. For example, to disconnect from the broker: Homie . getMqttClient (). disconnect ();","title":"Get access to the MQTT client"},{"location":"advanced-usage/range-properties/","text":"In all the previous examples you have seen, node properties were advertised one-by-one (e.g. temperature , unit ...). But what if you have a LED strip with, say, 100 properties, one for each LED? You won't advertise these 100 LEDs one-by-one. This is what range properties are meant for. HomieNode stripNode ( \"strip\" , \"strip\" ); bool ledHandler ( const HomieRange & range , const String & value ) { Homie . getLogger () << \"LED \" << range . index << \" set to \" << value << endl ; // Now, let's update the actual state of the given led stripNode . setProperty ( \"led\" ). setRange ( range ). send ( value ); } void setup () { stripNode . advertiseRange ( \"led\" , 1 , 100 ). settable ( ledHandler ); // before Homie.setup() } On the mqtt broker you will see the following message show up: topic message -------------------------------------------------------- homie/<device id>/strip/$type strip homie/<device id>/strip/$properties led[1-100]:settable You can then publish the value on to topic homie/<device id>/strip/led_1/set to turn on led number 1. See the following example for a concrete use case: LedStrip","title":"Range properties"},{"location":"advanced-usage/resetting/","text":"Resetting the device means erasing the stored configuration and rebooting from normal mode to configuration mode. By default, you can do it by pressing for 5 seconds the FLASH button of your ESP8266 board. This behavior is configurable: void setup () { Homie . setResetTrigger ( 1 , LOW , 2000 ); // before Homie.setup() // ... } The device will now reset if pin 1 is LOW for 2000 ms. You can also disable completely this reset trigger: void setup () { Homie . disableResetTrigger (); // before Homie.setup() // ... } In addition, you can also trigger a device reset from your sketch: void loop () { Homie . reset (); } This will reset the device as soon as it is idle. Indeed, sometimes, you might want to disable temporarily the ability to reset the device. For example, if your device is doing some background work like moving shutters, you will want to disable the ability to reset until the shutters are not moving anymore. Homie . setIdle ( false ); Note that if a reset is asked while the device is not idle, the device will be flagged. In other words, when you will call Homie.setIdle(true); back, the device will immediately reset.","title":"Resetting"},{"location":"advanced-usage/standalone-mode/","text":"Homie for ESP8266 has a special mode named standalone . It was a requested feature to implement a way not to boot into configuration mode on initial boot, so that a device can work without being configured first. It was already possible in configuration mode, but the device would spawn an AP which would make it insecure. To enable this mode, call Homie.setStandalone() : void setup () { Homie . setStandalone (); // before Homie.setup() // ... } To actually configure the device, you have to reset it, the same way you would to go from normal mode to configuration mode.","title":"Standalone mode"},{"location":"advanced-usage/streaming-operator/","text":"Homie for ESP8266 includes a nice streaming operator to interact with Print objects. Imagine the following code: int temperature = 32 ; Homie . getLogger (). print ( \"The current temperature is \" ); Homie . getLogger (). print ( temperature ); Homie . getLogger (). println ( \" \u00b0C.\" ); With the streaming operator, the following code will do exactly the same thing, without performance penalties: int temperature = 32 ; Homie . getLogger () << \"The current temperature is \" << temperature << \" \u00b0C.\" << endl ;","title":"Streaming operator"},{"location":"advanced-usage/ui-bundle/","text":"The Homie for ESP8266 configuration AP implements a captive portal. When connecting to it, you will be prompted to connect, and your Web browser will open. By default, it will show an empty page with a text saying to install an ui_bundle.gz file. Indeed, you can serve the configuration UI directly from your ESP8266. See the data/homie folder .","title":"UI Bundle"},{"location":"configuration/http-json-api/","text":"When in configuration mode, the device exposes a HTTP JSON API to send the configuration to it. When you send a valid configuration to the /config endpoint, the configuration file is stored in the filesystem at /homie/config.json . If you don't want to mess with JSON, you have a Web UI / app available: At http://marvinroger.github.io/homie-esp8266/configurators/v2/ As an Android app Quick instructions to use the Web UI / app : Open the Web UI / app Disconnect from your current Wi-Fi AP, and connect to the Homie-xxxxxxxxxxxx AP spawned in configuration mode Follow the instructions You can see the sources of the Web UI here . Alternatively, you can use this curl command to send the configuration to the device. You must connect to the device in configuration mode (i.e. the device is an Access Point). This method will not work if not in configuration mode: curl -X PUT http://192.168.123.1/config --header \"Content-Type: application/json\" -d @config.json This will send the ./config.json file to the device. Error handling \u00b6 When everything went fine, a 2xx HTTP code is returned, such as 200 OK , 202 Accepted , 204 No Content and so on. If anything goes wrong, a return code != 2xx will be returned, with a JSON error field indicating the error, such as 500 Internal Server error , 400 Bad request and so on. Endpoints \u00b6 API base address: http://192.168.123.1 GET /heart This is useful to ensure we are connected to the device AP. Response \u00b6 204 No Content GET /device-info Get some information on the device. Response \u00b6 200 OK (application/json) { \"hardware_device_id\" : \"52a8fa5d\" , \"homie_esp8266_version\" : \"2.0.0\" , \"firmware\" : { \"name\" : \"awesome-device\" , \"version\" : \"1.0.0\" }, \"nodes\" : [ { \"id\" : \"light\" , \"type\" : \"light\" } ], \"settings\" : [ { \"name\" : \"timeout\" , \"description\" : \"Timeout in seconds\" , \"type\" : \"ulong\" , \"required\" : false , \"default\" : 10 } ] } type can be one of the following: bool : a boolean ulong : an unsigned long long : a long double : a double string : a string Note about settings If a setting is not required, the default field will always be set. GET /networks Retrieve the Wi-Fi networks the device can see. Response \u00b6 In case of success 200 OK (application/json) { \"networks\" : [ { \"ssid\" : \"Network_2\" , \"rssi\" : -82 , \"encryption\" : \"wep\" }, { \"ssid\" : \"Network_1\" , \"rssi\" : -57 , \"encryption\" : \"wpa\" }, { \"ssid\" : \"Network_3\" , \"rssi\" : -65 , \"encryption\" : \"wpa2\" }, { \"ssid\" : \"Network_5\" , \"rssi\" : -94 , \"encryption\" : \"none\" }, { \"ssid\" : \"Network_4\" , \"rssi\" : -89 , \"encryption\" : \"auto\" } ] } In case the initial Wi-Fi scan is not finished on the device 503 Service Unavailable (application/json) { \"error\" : \"Initial Wi-Fi scan not finished yet\" } PUT /config Save the config to the device. Request body \u00b6 (application/json) See JSON configuration file . Response \u00b6 In case of success 200 OK (application/json) { \"success\" : true } In case of error in the payload 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" } In case the device already received a valid configuration and is waiting for reboot 403 Forbidden (application/json) { \"success\" : false , \"error\" : \"Device already configured\" } PUT /wifi/connect Initiates the connection of the device to the Wi-Fi network while in configuation mode. This request is not synchronous and the result (Wi-Fi connected or not) must be obtained by with GET /wifi/status . Request body \u00b6 (application/json) { \"ssid\" : \"My_SSID\" , \"password\" : \"my-passw0rd\" } Response \u00b6 In case of success 202 Accepted (application/json) { \"success\" : true } In case of error in the payload 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" } GET /wifi/status Returns the current Wi-Fi connection status. Helpful when monitoring Wi-Fi connectivity after PUT /wifi/connect . Response \u00b6 200 OK (application/json) { \"status\" : \"connected\" } status might be one of the following: idle connect_failed connection_lost no_ssid_available connected along with a local_ip field disconnected PUT /proxy/control Enable/disable the device to act as a transparent proxy between AP and Station networks. All requests that don't collide with existing API paths will be bridged to the destination according to the Host HTTP header. The destination host is called using the existing Wi-Fi connection (established after a PUT /wifi/connect ) and all contents are bridged back to the connection made to the AP side. This feature can be used to help captive portals to perform cloud API calls during device enrollment using the ESP8266 Wi-Fi AP connection without having to patch the Homie firmware. By using the transparent proxy, all operations can be performed by the custom JavaScript running on the browser (in SPIFFS location /data/homie/ui_bundle.gz ). HTTPS is not supported. Important : The HTTP requests and responses must be kept as small as possible because all contents are transported using RAM memory, which is very limited. Request body \u00b6 (application/json) { \"enable\" : true } Response \u00b6 In case of success 200 OK (application/json) { \"success\" : true } In case of error in the payload 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" }","title":"HTTP JSON API"},{"location":"configuration/http-json-api/#error-handling","text":"When everything went fine, a 2xx HTTP code is returned, such as 200 OK , 202 Accepted , 204 No Content and so on. If anything goes wrong, a return code != 2xx will be returned, with a JSON error field indicating the error, such as 500 Internal Server error , 400 Bad request and so on.","title":"Error handling"},{"location":"configuration/http-json-api/#endpoints","text":"API base address: http://192.168.123.1 GET /heart This is useful to ensure we are connected to the device AP.","title":"Endpoints"},{"location":"configuration/http-json-api/#response","text":"204 No Content GET /device-info Get some information on the device.","title":"Response"},{"location":"configuration/http-json-api/#response_1","text":"200 OK (application/json) { \"hardware_device_id\" : \"52a8fa5d\" , \"homie_esp8266_version\" : \"2.0.0\" , \"firmware\" : { \"name\" : \"awesome-device\" , \"version\" : \"1.0.0\" }, \"nodes\" : [ { \"id\" : \"light\" , \"type\" : \"light\" } ], \"settings\" : [ { \"name\" : \"timeout\" , \"description\" : \"Timeout in seconds\" , \"type\" : \"ulong\" , \"required\" : false , \"default\" : 10 } ] } type can be one of the following: bool : a boolean ulong : an unsigned long long : a long double : a double string : a string Note about settings If a setting is not required, the default field will always be set. GET /networks Retrieve the Wi-Fi networks the device can see.","title":"Response"},{"location":"configuration/http-json-api/#response_2","text":"In case of success 200 OK (application/json) { \"networks\" : [ { \"ssid\" : \"Network_2\" , \"rssi\" : -82 , \"encryption\" : \"wep\" }, { \"ssid\" : \"Network_1\" , \"rssi\" : -57 , \"encryption\" : \"wpa\" }, { \"ssid\" : \"Network_3\" , \"rssi\" : -65 , \"encryption\" : \"wpa2\" }, { \"ssid\" : \"Network_5\" , \"rssi\" : -94 , \"encryption\" : \"none\" }, { \"ssid\" : \"Network_4\" , \"rssi\" : -89 , \"encryption\" : \"auto\" } ] } In case the initial Wi-Fi scan is not finished on the device 503 Service Unavailable (application/json) { \"error\" : \"Initial Wi-Fi scan not finished yet\" } PUT /config Save the config to the device.","title":"Response"},{"location":"configuration/http-json-api/#request-body","text":"(application/json) See JSON configuration file .","title":"Request body"},{"location":"configuration/http-json-api/#response_3","text":"In case of success 200 OK (application/json) { \"success\" : true } In case of error in the payload 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" } In case the device already received a valid configuration and is waiting for reboot 403 Forbidden (application/json) { \"success\" : false , \"error\" : \"Device already configured\" } PUT /wifi/connect Initiates the connection of the device to the Wi-Fi network while in configuation mode. This request is not synchronous and the result (Wi-Fi connected or not) must be obtained by with GET /wifi/status .","title":"Response"},{"location":"configuration/http-json-api/#request-body_1","text":"(application/json) { \"ssid\" : \"My_SSID\" , \"password\" : \"my-passw0rd\" }","title":"Request body"},{"location":"configuration/http-json-api/#response_4","text":"In case of success 202 Accepted (application/json) { \"success\" : true } In case of error in the payload 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" } GET /wifi/status Returns the current Wi-Fi connection status. Helpful when monitoring Wi-Fi connectivity after PUT /wifi/connect .","title":"Response"},{"location":"configuration/http-json-api/#response_5","text":"200 OK (application/json) { \"status\" : \"connected\" } status might be one of the following: idle connect_failed connection_lost no_ssid_available connected along with a local_ip field disconnected PUT /proxy/control Enable/disable the device to act as a transparent proxy between AP and Station networks. All requests that don't collide with existing API paths will be bridged to the destination according to the Host HTTP header. The destination host is called using the existing Wi-Fi connection (established after a PUT /wifi/connect ) and all contents are bridged back to the connection made to the AP side. This feature can be used to help captive portals to perform cloud API calls during device enrollment using the ESP8266 Wi-Fi AP connection without having to patch the Homie firmware. By using the transparent proxy, all operations can be performed by the custom JavaScript running on the browser (in SPIFFS location /data/homie/ui_bundle.gz ). HTTPS is not supported. Important : The HTTP requests and responses must be kept as small as possible because all contents are transported using RAM memory, which is very limited.","title":"Response"},{"location":"configuration/http-json-api/#request-body_2","text":"(application/json) { \"enable\" : true }","title":"Request body"},{"location":"configuration/http-json-api/#response_6","text":"In case of success 200 OK (application/json) { \"success\" : true } In case of error in the payload 400 Bad Request (application/json) { \"success\" : false , \"error\" : \"Reason why the payload is invalid\" }","title":"Response"},{"location":"configuration/json-configuration-file/","text":"To configure your device, you have two choices: manually flashing the configuration file to the SPIFFS at the /homie/config.json (see Uploading files to file system ), so you can bypass the configuration mode, or send it through the HTTP JSON API . Below is the format of the JSON configuration you will have to provide: { \"name\" : \"The kitchen light\" , \"device_id\" : \"kitchen-light\" , \"device_stats_interval\" : 60 , \"wifi\" : { \"ssid\" : \"Network_1\" , \"password\" : \"I'm a Wi-Fi password!\" , \"bssid\" : \"DE:AD:BE:EF:BA:BE\" , \"channel\" : 1 , \"ip\" : \"192.168.1.5\" , \"mask\" : \"255.255.255.0\" , \"gw\" : \"192.168.1.1\" , \"dns1\" : \"8.8.8.8\" , \"dns2\" : \"8.8.4.4\" }, \"mqtt\" : { \"host\" : \"192.168.1.10\" , \"port\" : 1883 , \"base_topic\" : \"devices/\" , \"auth\" : true , \"username\" : \"user\" , \"password\" : \"pass\" }, \"ota\" : { \"enabled\" : true }, \"settings\" : { \"percentage\" : 55 } } The above JSON contains every field that can be customized. Here are the rules: name , wifi.ssid , wifi.password , mqtt.host and ota.enabled are mandatory wifi.password can be null if connecting to an open network If mqtt.auth is true , mqtt.username and mqtt.password must be provided bssid , channel , ip , mask , gw , dns1 , dns2 are not mandatory and are only needed to if there is a requirement to specify particular AP or set Static IP address. There are some rules which needs to be satisfied: bssid and channel have to be defined together and these settings are independand of settings related to static IP to define static IP, ip (IP address), mask (netmask) and gw (gateway) settings have to be defined at the same time to define second DNS dns2 the first one dns1 has to be defined. Set DNS without ip , mask and gw does not affect the configuration (dns server will be provided by DHCP). It is not required to set DNS servers. Default values if not provided: device_id : the hardware device ID (eg. 1a2b3c4d5e6f ) device_stats_interval : 60 seconds mqtt.port : 1883 mqtt.base_topic : homie/ mqtt.auth : false The mqtt.host field can be either an IP or an hostname.","title":"JSON configuration file"},{"location":"others/community-projects/","text":"This page lists the projects made by the community to work with Homie. jpmens/homie-ota \u00b6 homie-ota is written in Python. It provides an OTA server for Homie devices as well as a simple inventory which can be useful to keep track of Homie devices. homie-ota also enables you to trigger an OTA update (over MQTT, using the Homie convention) from within its inventory. New firmware can be uploaded to homie-ota which detects firmware name (fwname) and version (fwversion) from the uploaded binary blob, thanks to an idea and code contributed by Marvin. stufisher/homie-control \u00b6 homie-control provides a web UI to manage Homie devices as well as a series of virtual python devices to allow extended functionality. Its lets you do useful things like: Historically log device properties Schedule changes in event properties (i.e. water your garden once a day) Execute profiles of property values (i.e. turn a series of lights on and off simultaneously) Trigger property changes based on: When a network device is dis/connected (i.e. your phone joins your wifi, turn the lights on) Sunset / rise When another property changes","title":"Community projects"},{"location":"others/community-projects/#jpmenshomie-ota","text":"homie-ota is written in Python. It provides an OTA server for Homie devices as well as a simple inventory which can be useful to keep track of Homie devices. homie-ota also enables you to trigger an OTA update (over MQTT, using the Homie convention) from within its inventory. New firmware can be uploaded to homie-ota which detects firmware name (fwname) and version (fwversion) from the uploaded binary blob, thanks to an idea and code contributed by Marvin.","title":"jpmens/homie-ota"},{"location":"others/community-projects/#stufisherhomie-control","text":"homie-control provides a web UI to manage Homie devices as well as a series of virtual python devices to allow extended functionality. Its lets you do useful things like: Historically log device properties Schedule changes in event properties (i.e. water your garden once a day) Execute profiles of property values (i.e. turn a series of lights on and off simultaneously) Trigger property changes based on: When a network device is dis/connected (i.e. your phone joins your wifi, turn the lights on) Sunset / rise When another property changes","title":"stufisher/homie-control"},{"location":"others/cpp-api-reference/","text":"Homie \u00b6 You don't have to instantiate an Homie instance, it is done internally. void setup (); Setup Homie. Mandatory! Must be called once in setup() . void loop (); Handle Homie work. Mandatory! Must be called once in loop() . Functions to call before Homie.setup() \u00b6 void Homie_setFirmware ( const char * name , const char * version ); // This is not a typo Set the name and version of the firmware. This is useful for OTA, as Homie will check against the server if there is a newer version. Mandatory! You need to set the firmware for your sketch to work. name : Name of the firmware. Default value is undefined version : Version of the firmware. Default value is undefined void Homie_setBrand ( const char * name ); // This is not a typo Set the brand of the device, used in the configuration AP, the device hostname and the MQTT client ID. name : Name of the brand. Default value is Homie Homie & disableLogging (); Disable Homie logging. Homie & setLoggingPrinter ( Print * printer ); Set the Print instance used for logging. printer : Print instance to log to. By default, Serial is used Warning It's up to you to call Serial.begin() Homie & disableLedFeedback (); Disable the built-in LED feedback indicating the Homie for ESP8266 state. Homie & setLedPin ( uint8_t pin , uint8_t on ); Set pin of the LED to control. pin : LED to control on : state when the light is on (HIGH or LOW) Homie & setConfigurationApPassword ( const char * password ); Set the configuration AP password. password : the configuration AP password Homie & setGlobalInputHandler ( std :: function < bool ( const String & nodeId , const String & property , const HomieRange & range , const String & value ) > handler ); Set input handler for subscribed properties. handler : Global input handler node : Name of the node getting updated property : Property of the node getting updated range : Range of the property of the node getting updated value : Value of the new property Homie & setBroadcastHandler ( std :: function < bool ( const String & level , const String & value ) > handler ); Set broadcast handler. handler : Broadcast handler level : Level of the broadcast value : Value of the broadcast Homie & onEvent ( std :: function < void ( const HomieEvent & event ) > callback ); Set the event handler. Useful if you want to hook to Homie events. callback : Event handler Homie & setResetTrigger ( uint8_t pin , uint8_t state , uint16_t time ); Set the reset trigger. By default, the device will reset when pin 0 is LOW for 5000 ms. pin : Pin of the reset trigger state : Reset when the pin reaches this state for the given time time : Time necessary to reset Homie & disableResetTrigger (); Disable the reset trigger. Homie & setSetupFunction ( std :: function < void () > callback ); You can provide the function that will be called when operating in normal mode. callback : Setup function Homie & setLoopFunction ( std :: function < void () > callback ); You can provide the function that will be looped in normal mode. callback : Loop function Homie & setStandalone (); This will mark the Homie firmware as standalone, meaning it will first boot in standalone mode. To configure it and boot to configuration mode, the device has to be resetted. Functions to call after Homie.setup() \u00b6 void reset (); Flag the device for reset. void setIdle ( bool idle ); Set the device as idle or not. This is useful at runtime, because you might want the device not to be resettable when you have another library that is doing some unfinished work, like moving shutters for example. idle : Device in an idle state or not void prepareToSleep (); Prepare the device for deep sleep. It ensures messages are sent and disconnects cleanly from the MQTT broker, triggering a READY_TO_SLEEP event when done. void doDeepSleep ( uint32_t time_us = 0 , RFMode mode = RF_DEFAULT ); Puth the device into deep sleep. It ensures the Serial is flushed. bool isConfigured () const ; Is the device in normal mode, configured? bool isConnected () const ; Is the device in normal mode, configured and connected? const ConfigStruct & getConfiguration () const ; Get the configuration struct. Danger Be careful with this struct, never attempt to change it. AsyncMqttClient & getMqttClient (); Get the underlying AsyncMqttClient object. Logger & getLogger (); Get the underlying Logger object, which is only a wrapper around Serial by default. HomieNode \u00b6 HomieNode ( const char * id , const char * type , std :: function < bool ( const String & property , const HomieRange & range , const String & value ) > handler = ); Constructor of an HomieNode object. id : ID of the node type : Type of the node handler : Optional. Input handler of the node const char * getId () const ; Return the ID of the node. const char * getType () const ; Return the type of the node. PropertyInterface & advertise ( const char * property ); PropertyInterface & advertiseRange ( const char * property , uint16_t lower , uint16_t upper ); Advertise a property / range property on the node. property : Property to advertise lower : Lower bound of the range upper : Upper bound of the range This returns a reference to PropertyInterface on which you can call: void settable ( std :: function < bool ( const HomieRange & range , const String & value ) > handler ) = ); Make the property settable. handler : Optional. Input handler of the property SendingPromise & setProperty ( const String & property ); Using this function, you can set the value of a node property, like a temperature for example. property : Property to send This returns a reference to SendingPromise , on which you can call: SendingPromise & setQos ( uint8_t qos ); // defaults to 1 SendingPromise & setRetained ( bool retained ); // defaults to true SendingPromise & overwriteSetter ( bool overwrite ); // defaults to false SendingPromise & setRange ( const HomieRange & range ); // defaults to not a range SendingPromise & setRange ( uint16_t rangeIndex ); // defaults to not a range uint16_t send ( const String & value ); // finally send the property, return the packetId (or 0 if failure) Method names should be self-explanatory. HomieSetting \u00b6 HomieSetting < T > ( const char * name , const char * description ); Constructor of an HomieSetting object. T : Type of the setting. Either bool , unsigned long , long , double or const char* name : Name of the setting description : Description of the setting T get () const ; Get the default value if the setting is optional and not provided, or the provided value if the setting is required or optional but provided. bool wasProvided () const ; Return whether the setting was provided or not (otherwise get() would return the default value). Set the default value and make the setting optional. HomieSetting < T >& setDefaultValue ( T defaultValue ); defaultValue : The default value HomieSetting < T >& setValidator ( std :: function < bool ( T candidate ) > validator ); Set a validation function for the setting. The validator must return true if the candidate is correct, false otherwise. validator : The validation function","title":"C++ API reference"},{"location":"others/cpp-api-reference/#homie","text":"You don't have to instantiate an Homie instance, it is done internally. void setup (); Setup Homie. Mandatory! Must be called once in setup() . void loop (); Handle Homie work. Mandatory! Must be called once in loop() .","title":"Homie"},{"location":"others/cpp-api-reference/#functions-to-call-before-homiesetup","text":"void Homie_setFirmware ( const char * name , const char * version ); // This is not a typo Set the name and version of the firmware. This is useful for OTA, as Homie will check against the server if there is a newer version. Mandatory! You need to set the firmware for your sketch to work. name : Name of the firmware. Default value is undefined version : Version of the firmware. Default value is undefined void Homie_setBrand ( const char * name ); // This is not a typo Set the brand of the device, used in the configuration AP, the device hostname and the MQTT client ID. name : Name of the brand. Default value is Homie Homie & disableLogging (); Disable Homie logging. Homie & setLoggingPrinter ( Print * printer ); Set the Print instance used for logging. printer : Print instance to log to. By default, Serial is used Warning It's up to you to call Serial.begin() Homie & disableLedFeedback (); Disable the built-in LED feedback indicating the Homie for ESP8266 state. Homie & setLedPin ( uint8_t pin , uint8_t on ); Set pin of the LED to control. pin : LED to control on : state when the light is on (HIGH or LOW) Homie & setConfigurationApPassword ( const char * password ); Set the configuration AP password. password : the configuration AP password Homie & setGlobalInputHandler ( std :: function < bool ( const String & nodeId , const String & property , const HomieRange & range , const String & value ) > handler ); Set input handler for subscribed properties. handler : Global input handler node : Name of the node getting updated property : Property of the node getting updated range : Range of the property of the node getting updated value : Value of the new property Homie & setBroadcastHandler ( std :: function < bool ( const String & level , const String & value ) > handler ); Set broadcast handler. handler : Broadcast handler level : Level of the broadcast value : Value of the broadcast Homie & onEvent ( std :: function < void ( const HomieEvent & event ) > callback ); Set the event handler. Useful if you want to hook to Homie events. callback : Event handler Homie & setResetTrigger ( uint8_t pin , uint8_t state , uint16_t time ); Set the reset trigger. By default, the device will reset when pin 0 is LOW for 5000 ms. pin : Pin of the reset trigger state : Reset when the pin reaches this state for the given time time : Time necessary to reset Homie & disableResetTrigger (); Disable the reset trigger. Homie & setSetupFunction ( std :: function < void () > callback ); You can provide the function that will be called when operating in normal mode. callback : Setup function Homie & setLoopFunction ( std :: function < void () > callback ); You can provide the function that will be looped in normal mode. callback : Loop function Homie & setStandalone (); This will mark the Homie firmware as standalone, meaning it will first boot in standalone mode. To configure it and boot to configuration mode, the device has to be resetted.","title":"Functions to call before Homie.setup()"},{"location":"others/cpp-api-reference/#functions-to-call-after-homiesetup","text":"void reset (); Flag the device for reset. void setIdle ( bool idle ); Set the device as idle or not. This is useful at runtime, because you might want the device not to be resettable when you have another library that is doing some unfinished work, like moving shutters for example. idle : Device in an idle state or not void prepareToSleep (); Prepare the device for deep sleep. It ensures messages are sent and disconnects cleanly from the MQTT broker, triggering a READY_TO_SLEEP event when done. void doDeepSleep ( uint32_t time_us = 0 , RFMode mode = RF_DEFAULT ); Puth the device into deep sleep. It ensures the Serial is flushed. bool isConfigured () const ; Is the device in normal mode, configured? bool isConnected () const ; Is the device in normal mode, configured and connected? const ConfigStruct & getConfiguration () const ; Get the configuration struct. Danger Be careful with this struct, never attempt to change it. AsyncMqttClient & getMqttClient (); Get the underlying AsyncMqttClient object. Logger & getLogger (); Get the underlying Logger object, which is only a wrapper around Serial by default.","title":"Functions to call after Homie.setup()"},{"location":"others/cpp-api-reference/#homienode","text":"HomieNode ( const char * id , const char * type , std :: function < bool ( const String & property , const HomieRange & range , const String & value ) > handler = ); Constructor of an HomieNode object. id : ID of the node type : Type of the node handler : Optional. Input handler of the node const char * getId () const ; Return the ID of the node. const char * getType () const ; Return the type of the node. PropertyInterface & advertise ( const char * property ); PropertyInterface & advertiseRange ( const char * property , uint16_t lower , uint16_t upper ); Advertise a property / range property on the node. property : Property to advertise lower : Lower bound of the range upper : Upper bound of the range This returns a reference to PropertyInterface on which you can call: void settable ( std :: function < bool ( const HomieRange & range , const String & value ) > handler ) = ); Make the property settable. handler : Optional. Input handler of the property SendingPromise & setProperty ( const String & property ); Using this function, you can set the value of a node property, like a temperature for example. property : Property to send This returns a reference to SendingPromise , on which you can call: SendingPromise & setQos ( uint8_t qos ); // defaults to 1 SendingPromise & setRetained ( bool retained ); // defaults to true SendingPromise & overwriteSetter ( bool overwrite ); // defaults to false SendingPromise & setRange ( const HomieRange & range ); // defaults to not a range SendingPromise & setRange ( uint16_t rangeIndex ); // defaults to not a range uint16_t send ( const String & value ); // finally send the property, return the packetId (or 0 if failure) Method names should be self-explanatory.","title":"HomieNode"},{"location":"others/cpp-api-reference/#homiesetting","text":"HomieSetting < T > ( const char * name , const char * description ); Constructor of an HomieSetting object. T : Type of the setting. Either bool , unsigned long , long , double or const char* name : Name of the setting description : Description of the setting T get () const ; Get the default value if the setting is optional and not provided, or the provided value if the setting is required or optional but provided. bool wasProvided () const ; Return whether the setting was provided or not (otherwise get() would return the default value). Set the default value and make the setting optional. HomieSetting < T >& setDefaultValue ( T defaultValue ); defaultValue : The default value HomieSetting < T >& setValidator ( std :: function < bool ( T candidate ) > validator ); Set a validation function for the setting. The validator must return true if the candidate is correct, false otherwise. validator : The validation function","title":"HomieSetting"},{"location":"others/homie-implementation-specifics/","text":"The Homie $implementation identifier is esp8266 . Version \u00b6 $implementation/version : Homie for ESP8266 version Reset \u00b6 $implementation/reset : You can publish a true to this topic to reset the device Configuration \u00b6 $implementation/config : The configuration.json is published there, with wifi.password , mqtt.username and mqtt.password fields stripped $implementation/config/set : You can update the configuration.json by sending incremental JSON on this topic OTA \u00b6 $implementation/ota/enabled : true if OTA is enabled, false otherwise $implementation/ota/firmware : If the update request is accepted, you must send the firmware payload to this topic $implementation/ota/status : HTTP-like status code indicating the status of the OTA. Might be: Code Description 200 OTA successfully flashed 202 OTA request / checksum accepted 206 465/349680 OTA in progress. The data after the status code corresponds to <bytes written>/<bytes total> 304 The current firmware is already up-to-date 400 BAD_FIRMWARE OTA error from your side. The identifier might be BAD_FIRMWARE , BAD_CHECKSUM , NOT_ENOUGH_SPACE , NOT_REQUESTED 403 OTA not enabled 500 FLASH_ERROR OTA error on the ESP8266. The identifier might be FLASH_ERROR","title":"Homie implementation specifics"},{"location":"others/homie-implementation-specifics/#version","text":"$implementation/version : Homie for ESP8266 version","title":"Version"},{"location":"others/homie-implementation-specifics/#reset","text":"$implementation/reset : You can publish a true to this topic to reset the device","title":"Reset"},{"location":"others/homie-implementation-specifics/#configuration","text":"$implementation/config : The configuration.json is published there, with wifi.password , mqtt.username and mqtt.password fields stripped $implementation/config/set : You can update the configuration.json by sending incremental JSON on this topic","title":"Configuration"},{"location":"others/homie-implementation-specifics/#ota","text":"$implementation/ota/enabled : true if OTA is enabled, false otherwise $implementation/ota/firmware : If the update request is accepted, you must send the firmware payload to this topic $implementation/ota/status : HTTP-like status code indicating the status of the OTA. Might be: Code Description 200 OTA successfully flashed 202 OTA request / checksum accepted 206 465/349680 OTA in progress. The data after the status code corresponds to <bytes written>/<bytes total> 304 The current firmware is already up-to-date 400 BAD_FIRMWARE OTA error from your side. The identifier might be BAD_FIRMWARE , BAD_CHECKSUM , NOT_ENOUGH_SPACE , NOT_REQUESTED 403 OTA not enabled 500 FLASH_ERROR OTA error on the ESP8266. The identifier might be FLASH_ERROR","title":"OTA"},{"location":"others/limitations-and-known-issues/","text":"SSL support \u00b6 In Homie for ESP8266 v1.x, SSL was possible but it was not reliable. Due to the asynchronous nature of the v2.x, SSL is not available anymore. ADC readings \u00b6 This is a known esp8266/Arduino issue that polling analogRead() too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms. Wi-Fi connection \u00b6 If you encouter any issues with the Wi-Fi, try changing the flash size build parameter, or try to erase the flash. See #158 for more information.","title":"Limitations and known issues"},{"location":"others/limitations-and-known-issues/#ssl-support","text":"In Homie for ESP8266 v1.x, SSL was possible but it was not reliable. Due to the asynchronous nature of the v2.x, SSL is not available anymore.","title":"SSL support"},{"location":"others/limitations-and-known-issues/#adc-readings","text":"This is a known esp8266/Arduino issue that polling analogRead() too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms.","title":"ADC readings"},{"location":"others/limitations-and-known-issues/#wi-fi-connection","text":"If you encouter any issues with the Wi-Fi, try changing the flash size build parameter, or try to erase the flash. See #158 for more information.","title":"Wi-Fi connection"},{"location":"others/ota-configuration-updates/","text":"OTA updates \u00b6 Homie for ESP8266 supports OTA, if enabled in the configuration, and if a compatible OTA entity is set up. There's a script that does just that: ota_updater.py It works this way: During startup of the Homie for ESP8266 device, it reports the current firmware's MD5 to $fw/checksum (in addition to $fw/name and $fw/version ). The OTA entity may or may not use this information to automatically schedule OTA updates The OTA entity publishes the latest available firmware payload to $implementation/ota/firmware/<md5 checksum> , either as binary or as a Base64 encoded string If OTA is disabled, Homie for ESP8266 reports 403 to $implementation/ota/status and aborts the OTA If OTA is enabled and the latest available checksum is the same as what is currently running, Homie for ESP8266 reports 304 and aborts the OTA If the checksum is not a valid MD5, Homie for ESP8266 reports 400 BAD_CHECKSUM to $implementation/ota/status and aborts the OTA Homie starts to flash the firmware The firmware is updating. Homie for ESP8266 reports progress with 206 <bytes written>/<bytes total> When all bytes are flashed, the firmware is verified (including the MD5 if one was set) Homie for ESP8266 either reports 200 on success, 400 if the firmware in invalid or 500 if there's an internal error Homie for ESP8266 reboots on success as soon as the device is idle See Homie implementation specifics for more details on status codes. OTA entities projects \u00b6 See Community projects . Configuration updates \u00b6 In normal mode, you can get the current config.json , published on $implementation/config with wifi.password , mqtt.username and mqtt.password stripped. You can update the configuration on-the-fly by publishing incremental JSON updates to $implementation/config/set . For example, given the following config.json : { \"name\" : \"Kitchen light\" , \"wifi\" : { \"ssid\" : \"Network_1\" , \"password\" : \"I'm a Wi-Fi password!\" }, \"mqtt\" : { \"host\" : \"192.168.1.20\" , \"port\" : 1883 }, \"ota\" : { \"enabled\" : false }, \"settings\" : { } } You can update the name and Wi-Fi password by sending the following incremental JSON: { \"name\" : \"Living room light\" , \"wifi\" : { \"password\" : \"I'am a new Wi-Fi password!\" } }","title":"OTA/configuration updates"},{"location":"others/ota-configuration-updates/#ota-updates","text":"Homie for ESP8266 supports OTA, if enabled in the configuration, and if a compatible OTA entity is set up. There's a script that does just that: ota_updater.py It works this way: During startup of the Homie for ESP8266 device, it reports the current firmware's MD5 to $fw/checksum (in addition to $fw/name and $fw/version ). The OTA entity may or may not use this information to automatically schedule OTA updates The OTA entity publishes the latest available firmware payload to $implementation/ota/firmware/<md5 checksum> , either as binary or as a Base64 encoded string If OTA is disabled, Homie for ESP8266 reports 403 to $implementation/ota/status and aborts the OTA If OTA is enabled and the latest available checksum is the same as what is currently running, Homie for ESP8266 reports 304 and aborts the OTA If the checksum is not a valid MD5, Homie for ESP8266 reports 400 BAD_CHECKSUM to $implementation/ota/status and aborts the OTA Homie starts to flash the firmware The firmware is updating. Homie for ESP8266 reports progress with 206 <bytes written>/<bytes total> When all bytes are flashed, the firmware is verified (including the MD5 if one was set) Homie for ESP8266 either reports 200 on success, 400 if the firmware in invalid or 500 if there's an internal error Homie for ESP8266 reboots on success as soon as the device is idle See Homie implementation specifics for more details on status codes.","title":"OTA updates"},{"location":"others/ota-configuration-updates/#ota-entities-projects","text":"See Community projects .","title":"OTA entities projects"},{"location":"others/ota-configuration-updates/#configuration-updates","text":"In normal mode, you can get the current config.json , published on $implementation/config with wifi.password , mqtt.username and mqtt.password stripped. You can update the configuration on-the-fly by publishing incremental JSON updates to $implementation/config/set . For example, given the following config.json : { \"name\" : \"Kitchen light\" , \"wifi\" : { \"ssid\" : \"Network_1\" , \"password\" : \"I'm a Wi-Fi password!\" }, \"mqtt\" : { \"host\" : \"192.168.1.20\" , \"port\" : 1883 }, \"ota\" : { \"enabled\" : false }, \"settings\" : { } } You can update the name and Wi-Fi password by sending the following incremental JSON: { \"name\" : \"Living room light\" , \"wifi\" : { \"password\" : \"I'am a new Wi-Fi password!\" } }","title":"Configuration updates"},{"location":"others/troubleshooting/","text":"1. I see some garbage on the Serial monitor? \u00b6 You are probably using a generic ESP8266. The problem with these modules is the built-in LED is tied to the serial line. You can do two things: Disable the serial logging, to have the LED working: void setup () { Homie . enableLogging ( false ); // before Homie.setup() // ... } Disable the LED blinking, to have the serial line working: void setup () { Homie . enableBuiltInLedIndicator ( false ); // before Homie.setup() // ... } 2. I see an abort message on the Serial monitor? \u00b6 abort() is called by Homie for ESP8266 when the framework is used in a bad way. The possible causes are: You are calling a function that is meant to be called before Homie.setup() , after Homie.setup() One of the string you've used (in setFirmware() , subscribe() , etc.) is too long. Check the Limits.hpp file to see the max length possible for each string. 3. The network is completely unstable... What's going on? \u00b6 The framework needs to work continuously (ie. Homie.loop() needs to be called very frequently). In other words, don't use delay() (see avoid delay ) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with analogRead() , see Limitations and known issues . 4. My device resets itself without me doing anything? \u00b6 You have probably connected a sensor to the default reset pin of the framework (D3 on NodeMCU, GPIO0 on other boards). See Resetting .","title":"Troubleshooting"},{"location":"others/troubleshooting/#1-i-see-some-garbage-on-the-serial-monitor","text":"You are probably using a generic ESP8266. The problem with these modules is the built-in LED is tied to the serial line. You can do two things: Disable the serial logging, to have the LED working: void setup () { Homie . enableLogging ( false ); // before Homie.setup() // ... } Disable the LED blinking, to have the serial line working: void setup () { Homie . enableBuiltInLedIndicator ( false ); // before Homie.setup() // ... }","title":"1. I see some garbage on the Serial monitor?"},{"location":"others/troubleshooting/#2-i-see-an-abort-message-on-the-serial-monitor","text":"abort() is called by Homie for ESP8266 when the framework is used in a bad way. The possible causes are: You are calling a function that is meant to be called before Homie.setup() , after Homie.setup() One of the string you've used (in setFirmware() , subscribe() , etc.) is too long. Check the Limits.hpp file to see the max length possible for each string.","title":"2. I see an abort message on the Serial monitor?"},{"location":"others/troubleshooting/#3-the-network-is-completely-unstable-whats-going-on","text":"The framework needs to work continuously (ie. Homie.loop() needs to be called very frequently). In other words, don't use delay() (see avoid delay ) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with analogRead() , see Limitations and known issues .","title":"3. The network is completely unstable... What's going on?"},{"location":"others/troubleshooting/#4-my-device-resets-itself-without-me-doing-anything","text":"You have probably connected a sensor to the default reset pin of the framework (D3 on NodeMCU, GPIO0 on other boards). See Resetting .","title":"4. My device resets itself without me doing anything?"},{"location":"others/upgrade-guide-from-v1-to-v2/","text":"This is an upgrade guide to upgrade your Homie devices from v1 to v2. New convention \u00b6 The Homie convention has been revised to v2 to be more extensible and introspectable. Be sure to check it out . API changes in the sketch \u00b6 Homie.setFirmware(name, version) must be replaced by Homie_setFirmware(name, version) Homie.setBrand(brand) must be replaced by Homie_setBrand(brand) Homie.registerNode() must be removed, nodes are now automagically registered If you've enabled Serial logging, Serial.begin() must be called explicitely in your sketch Remove the HOMIE_OTA_MODE in your event handler, if you have one The Homie.setNodeProperty() signature changed completely. If you had Homie.setNodeProperty(node, \"property\", \"value\", true) , the new equivalent syntax is Homie.setNodeProperty(node, \"property\").setRetained(true).send(\"value\") . Note the setRetained() is not even required as messages are retained by default. TODO","title":"Upgrade guide from v1 to v2"},{"location":"others/upgrade-guide-from-v1-to-v2/#new-convention","text":"The Homie convention has been revised to v2 to be more extensible and introspectable. Be sure to check it out .","title":"New convention"},{"location":"others/upgrade-guide-from-v1-to-v2/#api-changes-in-the-sketch","text":"Homie.setFirmware(name, version) must be replaced by Homie_setFirmware(name, version) Homie.setBrand(brand) must be replaced by Homie_setBrand(brand) Homie.registerNode() must be removed, nodes are now automagically registered If you've enabled Serial logging, Serial.begin() must be called explicitely in your sketch Remove the HOMIE_OTA_MODE in your event handler, if you have one The Homie.setNodeProperty() signature changed completely. If you had Homie.setNodeProperty(node, \"property\", \"value\", true) , the new equivalent syntax is Homie.setNodeProperty(node, \"property\").setRetained(true).send(\"value\") . Note the setRetained() is not even required as messages are retained by default. TODO","title":"API changes in the sketch"},{"location":"quickstart/getting-started/","text":"This Getting Started guide assumes you have an ESP8266 board with an user-configurable LED, and an user programmable button, like a NodeMCU DevKit 1.0, for example. These restrictions can be lifted (see next pages). To use Homie for ESP8266, you will need: An ESP8266 The Arduino IDE for ESP8266 (version 2.3.0 minimum) Basic knowledge of the Arduino environment (upload a sketch, import libraries, ...) To understand the Homie convention Installing Homie for ESP8266 \u00b6 There are two ways to install Homie for ESP8266. 1a. For the Arduino IDE \u00b6 There is a YouTube video with instructions: How to install Homie libraries on Arduino IDE Download the release corresponding to this documentation version Load the .zip with Sketch \u2192 Include Library \u2192 Add .ZIP Library Homie for ESP8266 has 5 dependencies: ArduinoJson >= 5.0.8 Bounce2 ESPAsyncTCP >= c8ed544 AsyncMqttClient ESPAsyncWebServer Some of them are available through the Arduino IDE, with Sketch \u2192 Include Library \u2192 Manage Libraries . For the others, install it by downloading the .zip on GitHub. 1b. With PlatformIO \u00b6 In a terminal, run platformio lib install 555 . Not yet released as stable The above command is for when the v2 is stable and released. Currently, the latest stable version is 1.5. In the meantime, use the develop branch to get started with the v2, add this in your platformio.ini : lib_deps = git+https://github.com/homieiot/homie-esp8266.git#develop Dependencies are installed automatically. Bare minimum sketch \u00b6 #include <Homie.h> void setup () { Serial . begin ( 115200 ); Serial << endl << endl ; Homie_setFirmware ( \"bare-minimum\" , \"1.0.0\" ); // The underscore is not a typo! See Magic bytes Homie . setup (); } void loop () { Homie . loop (); } This is the bare minimum needed for Homie for ESP8266 to work correctly. LED If you upload this sketch, you will notice the LED of the ESP8266 will light on. This is because you are in configuration mode. Homie for ESP8266 has 3 modes of operation: By default, the configuration mode is the initial one. It spawns an AP and an HTTP webserver exposing a JSON API. To interact with it, you have to connect to the AP. Then, an HTTP client can get the list of available Wi-Fi networks and send the configuration (like the Wi-Fi SSID, the Wi-Fi password, some settings...). Once the device receives the credentials, it boots into normal mode. The normal mode is the mode the device will be most of the time. It connects to the Wi-Fi, to the MQTT, it sends initial informations to the Homie server (like the local IP, the version of the firmware currently running...) and it subscribes to the needed MQTT topics. It automatically reconnects to the Wi-Fi and the MQTT when the connection is lost. It also handle the OTA. The device can return to configuration mode in different ways (press of a button or custom function, see Resetting ). The standalone mode. See Standalone mode . Warning As a rule of thumb, never block the device with blocking code for more than 50ms or so. Otherwise, you may very probably experience unexpected behaviors. Connecting to the AP and configuring the device \u00b6 Homie for ESP8266 has spawned a secure AP named Homie-xxxxxxxxxxxx , like Homie-c631f278df44 . Connect to it. Hardware device ID This c631f278df44 ID is unique to each device, and you cannot change it (this is actually the MAC address of the station mode). If you flash a new sketch, this ID won't change. Once connected, the webserver is available at http://192.168.123.1 . Every domain name is resolved by the built-in DNS server to this address. You can then configure the device using the HTTP JSON API . When the device receives its configuration, it will reboot into normal mode. Understanding what happens in normal mode \u00b6 Visual codes \u00b6 When the device boots in normal mode, it will start blinking: LED Slowly when connecting to the Wi-Fi LED Faster when connecting to the MQTT broker This way, you can have a quick feedback on what's going on. If both connections are established, the LED will stay off. Note the device will also blink during the automatic reconnection, if the connection to the Wi-Fi or the MQTT broker is lost. Under the hood \u00b6 Although the sketch looks like it does not do anything, it actually does quite a lot: It automatically connects to the Wi-Fi and MQTT broker. No more network boilerplate code It exposes the Homie device on MQTT (as <base topic>/<device ID> , e.g. homie/c631f278df44 ) It subscribes to the special OTA and configuration topics, automatically flashing a sketch if available or updating the configuration It checks for a button press on the ESP8266, to return to configuration mode Creating an useful sketch \u00b6 Now that we understand how Homie for ESP8266 works, let's create an useful sketch. We want to create a smart light. LightOnOff.ino Alright, step by step: We create a node with an ID of light and a type of switch with HomieNode lightNode(\"light\", \"switch\") We set the name and the version of the firmware with Homie_setFirmware(\"awesome-light\" ,\"1.0.0\"); We want our light node to advertise an on property, which is settable. We do that with lightNode.advertise(\"on\").settable(lightOnHandler); . The lightOnHandler function will be called when the value of this property is changed In the lightOnHandler function, we want to update the state of the light node. We do this with lightNode.setProperty(\"on\").send(\"true\"); In about thirty SLOC, we have achieved to create a smart light, without any hard-coded credentials, with automatic reconnection in case of network failure, and with OTA support. Not bad, right? Creating a sensor node \u00b6 In the previous example sketch, we were reacting to property changes. But what if we want, for example, to send a temperature every 5 minutes? We could do this in the Arduino loop() function. But then, we would have to check if we are in normal mode, and we would have to ensure the network connection is up before being able to send anything. Boring. Fortunately, Homie for ESP8266 provides an easy way to do that. TemperatureSensor.ino The only new things here are the Homie.setSetupFunction(setupHandler); and Homie.setLoopFunction(loopHandler); calls. The setup function will be called once, when the device is in normal mode and the network connection is up. The loop function will be called everytime, when the device is in normal mode and the network connection is up. This provides a nice level of abstraction. Now that you understand the basic usage of Homie for ESP8266, you can head on to the next pages to learn about more powerful features like input handlers, the event system and custom settings.","title":"Getting started"},{"location":"quickstart/getting-started/#installing-homie-for-esp8266","text":"There are two ways to install Homie for ESP8266.","title":"Installing Homie for ESP8266"},{"location":"quickstart/getting-started/#1a-for-the-arduino-ide","text":"There is a YouTube video with instructions: How to install Homie libraries on Arduino IDE Download the release corresponding to this documentation version Load the .zip with Sketch \u2192 Include Library \u2192 Add .ZIP Library Homie for ESP8266 has 5 dependencies: ArduinoJson >= 5.0.8 Bounce2 ESPAsyncTCP >= c8ed544 AsyncMqttClient ESPAsyncWebServer Some of them are available through the Arduino IDE, with Sketch \u2192 Include Library \u2192 Manage Libraries . For the others, install it by downloading the .zip on GitHub.","title":"1a. For the Arduino IDE"},{"location":"quickstart/getting-started/#1b-with-platformio","text":"In a terminal, run platformio lib install 555 . Not yet released as stable The above command is for when the v2 is stable and released. Currently, the latest stable version is 1.5. In the meantime, use the develop branch to get started with the v2, add this in your platformio.ini : lib_deps = git+https://github.com/homieiot/homie-esp8266.git#develop Dependencies are installed automatically.","title":"1b. With PlatformIO"},{"location":"quickstart/getting-started/#bare-minimum-sketch","text":"#include <Homie.h> void setup () { Serial . begin ( 115200 ); Serial << endl << endl ; Homie_setFirmware ( \"bare-minimum\" , \"1.0.0\" ); // The underscore is not a typo! See Magic bytes Homie . setup (); } void loop () { Homie . loop (); } This is the bare minimum needed for Homie for ESP8266 to work correctly. LED If you upload this sketch, you will notice the LED of the ESP8266 will light on. This is because you are in configuration mode. Homie for ESP8266 has 3 modes of operation: By default, the configuration mode is the initial one. It spawns an AP and an HTTP webserver exposing a JSON API. To interact with it, you have to connect to the AP. Then, an HTTP client can get the list of available Wi-Fi networks and send the configuration (like the Wi-Fi SSID, the Wi-Fi password, some settings...). Once the device receives the credentials, it boots into normal mode. The normal mode is the mode the device will be most of the time. It connects to the Wi-Fi, to the MQTT, it sends initial informations to the Homie server (like the local IP, the version of the firmware currently running...) and it subscribes to the needed MQTT topics. It automatically reconnects to the Wi-Fi and the MQTT when the connection is lost. It also handle the OTA. The device can return to configuration mode in different ways (press of a button or custom function, see Resetting ). The standalone mode. See Standalone mode . Warning As a rule of thumb, never block the device with blocking code for more than 50ms or so. Otherwise, you may very probably experience unexpected behaviors.","title":"Bare minimum sketch"},{"location":"quickstart/getting-started/#connecting-to-the-ap-and-configuring-the-device","text":"Homie for ESP8266 has spawned a secure AP named Homie-xxxxxxxxxxxx , like Homie-c631f278df44 . Connect to it. Hardware device ID This c631f278df44 ID is unique to each device, and you cannot change it (this is actually the MAC address of the station mode). If you flash a new sketch, this ID won't change. Once connected, the webserver is available at http://192.168.123.1 . Every domain name is resolved by the built-in DNS server to this address. You can then configure the device using the HTTP JSON API . When the device receives its configuration, it will reboot into normal mode.","title":"Connecting to the AP and configuring the device"},{"location":"quickstart/getting-started/#understanding-what-happens-in-normal-mode","text":"","title":"Understanding what happens in normal mode"},{"location":"quickstart/getting-started/#visual-codes","text":"When the device boots in normal mode, it will start blinking: LED Slowly when connecting to the Wi-Fi LED Faster when connecting to the MQTT broker This way, you can have a quick feedback on what's going on. If both connections are established, the LED will stay off. Note the device will also blink during the automatic reconnection, if the connection to the Wi-Fi or the MQTT broker is lost.","title":"Visual codes"},{"location":"quickstart/getting-started/#under-the-hood","text":"Although the sketch looks like it does not do anything, it actually does quite a lot: It automatically connects to the Wi-Fi and MQTT broker. No more network boilerplate code It exposes the Homie device on MQTT (as <base topic>/<device ID> , e.g. homie/c631f278df44 ) It subscribes to the special OTA and configuration topics, automatically flashing a sketch if available or updating the configuration It checks for a button press on the ESP8266, to return to configuration mode","title":"Under the hood"},{"location":"quickstart/getting-started/#creating-an-useful-sketch","text":"Now that we understand how Homie for ESP8266 works, let's create an useful sketch. We want to create a smart light. LightOnOff.ino Alright, step by step: We create a node with an ID of light and a type of switch with HomieNode lightNode(\"light\", \"switch\") We set the name and the version of the firmware with Homie_setFirmware(\"awesome-light\" ,\"1.0.0\"); We want our light node to advertise an on property, which is settable. We do that with lightNode.advertise(\"on\").settable(lightOnHandler); . The lightOnHandler function will be called when the value of this property is changed In the lightOnHandler function, we want to update the state of the light node. We do this with lightNode.setProperty(\"on\").send(\"true\"); In about thirty SLOC, we have achieved to create a smart light, without any hard-coded credentials, with automatic reconnection in case of network failure, and with OTA support. Not bad, right?","title":"Creating an useful sketch"},{"location":"quickstart/getting-started/#creating-a-sensor-node","text":"In the previous example sketch, we were reacting to property changes. But what if we want, for example, to send a temperature every 5 minutes? We could do this in the Arduino loop() function. But then, we would have to check if we are in normal mode, and we would have to ensure the network connection is up before being able to send anything. Boring. Fortunately, Homie for ESP8266 provides an easy way to do that. TemperatureSensor.ino The only new things here are the Homie.setSetupFunction(setupHandler); and Homie.setLoopFunction(loopHandler); calls. The setup function will be called once, when the device is in normal mode and the network connection is up. The loop function will be called everytime, when the device is in normal mode and the network connection is up. This provides a nice level of abstraction. Now that you understand the basic usage of Homie for ESP8266, you can head on to the next pages to learn about more powerful features like input handlers, the event system and custom settings.","title":"Creating a sensor node"},{"location":"quickstart/what-is-it/","text":"Homie for ESP8266 is an ESP8266 for Arduino implementation of Homie , a thin and simple MQTT convention for the IoT. More than that, it's also a full-featured framework to get started with your IoT project very quickly. Simply put, you don't have to manage yourself the connection/reconnection to the Wi-Fi/MQTT. You don't even have to hard-code credentials in your sketch: this can be done using a simple JSON API. Everything is handled internally, by Homie for ESP8266. You guessed it, the purpose of Homie for ESP8266 is to simplify the development of connected objects.","title":"What is it?"}]}